<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>clingox.backends API documentation</title>
<meta name="description" content="This module provides a backend wrapper to work with symbols instead of integer
literals." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clingox.backends</code></h1>
</header>
<section id="section-intro">
<p>This module provides a backend wrapper to work with symbols instead of integer
literals.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
This module provides a backend wrapper to work with symbols instead of integer
literals.
&#39;&#39;&#39;
from typing import Iterable, Tuple
from itertools import chain
from clingo import HeuristicType, Symbol, Backend, TruthValue


def _add_sign(lit: int, sign: bool):
    &#39;&#39;&#39;
    Invert the literal if sign is negative and otherwise leave it untouched.
    &#39;&#39;&#39;
    return lit if sign else -lit

class SymbolicBackend():
    &#39;&#39;&#39;
    Backend wrapper providing a interface to extend a logic program. It mirrors
    the interface of clingo&#39;s Backend, but using Symbols rather than integers
    to represent literals.

    Implements: `ContextManager[SymbolicBackend]`.

    See Also
    --------
    clingo.Backend, clingo.Control.backend

    Notes
    --------
    The `SymbolicBackend` is a context manager and must be used with Python&#39;s
    `with` statement.

    Examples
    --------
    The following example shows how to add the rules

        a :- b, not c.
        b.

    to a program:

        &gt;&gt;&gt; import clingo
        &gt;&gt;&gt; from clingox.backends import SymbolicBackend
        &gt;&gt;&gt; ctl = clingo.Control()
        &gt;&gt;&gt; a = clingo.Function(&#34;a&#34;)
        &gt;&gt;&gt; b = clingo.Function(&#34;b&#34;)
        &gt;&gt;&gt; c = clingo.Function(&#34;c&#34;)
        &gt;&gt;&gt; with SymbolicBackend(ctl.backend()) as symbolic_backend:
                symbolic_backend.add_rule([a], [b], [c])
                symbolic_backend.add_rule([b])
        &gt;&gt;&gt; ctl.solve(on_model=lambda m: print(&#34;Answer: {}&#34;.format(m)))
        Answer: a b
        SAT

    The `SymbolicBackend` can also be used in combination with the `Backend`
    that it wraps. In this case, it is the `Backend` that must be used with
    Python&#39;s `with` statement:

        &gt;&gt;&gt; import clingo
        &gt;&gt;&gt; from clingox.backends import SymbolicBackend
        &gt;&gt;&gt; ctl = clingo.Control()
        &gt;&gt;&gt; a = clingo.Function(&#34;a&#34;)
        &gt;&gt;&gt; b = clingo.Function(&#34;b&#34;)
        &gt;&gt;&gt; c = clingo.Function(&#34;c&#34;)
        &gt;&gt;&gt; with ctl.backend() as backend:
                symbolic_backend = SymbolicBackend(backend)
                symbolic_backend.add_rule([a], [b], [c])
                atom_b = backend.add_atom(b)
                backend.add_rule([atom_b])
        &gt;&gt;&gt; ctl.solve(on_model=lambda m: print(&#34;Answer: {}&#34;.format(m)))
        Answer: a b
        SAT
    &#39;&#39;&#39;
    def __init__(self, backend: Backend):
        self.backend: Backend = backend

    def __enter__(self):
        &#39;&#39;&#39;
        Initialize the backend.

        Returns
        -------
        Backend
            Returns the backend itself.

        Notes
        -----
        Must be called before using the backend.
        &#39;&#39;&#39;
        self.backend.__enter__()
        return self

    def __exit__(self, type_, value, traceback):
        &#39;&#39;&#39;
        Finalize the backend.

        Notes
        -----
        Follows Python&#39;s __exit__ conventions. Does not suppress exceptions.
        &#39;&#39;&#39;
        return self.backend.__exit__(type_, value, traceback)

    def add_acyc_edge(self, node_u: int, node_v: int, pos_condition: Iterable[Symbol],
                      neg_condition: Iterable[Symbol]) -&gt; None:
        &#39;&#39;&#39;
        Add an edge directive to the underlying backend.

        Parameters
        ----------
        node_u : int
            The start node represented as an unsigned integer.
        node_v : int
            The end node represented as an unsigned integer.
        pos_condition : Iterable[Symbol]
            List of program symbols forming positive part of the condition.
        neg_condition : Iterable[Symbol]
            List of program symbols forming negated part of the condition.

        Returns
        -------
        None
        &#39;&#39;&#39;
        condition = chain(self._add_lits(pos_condition, True), self._add_lits(neg_condition, False))
        self.backend.add_acyc_edge(node_u, node_v, condition)

    def add_assume(self, pos_atoms: Iterable[Symbol] = (), neg_atoms: Iterable[Symbol] = ()) -&gt; None:
        &#39;&#39;&#39;
        Add assumptions to the underlying backend.

        Parameters
        ----------
        pos_atoms : Iterable[Symbol]
            Atoms to assume true.
        neg_atoms : Iterable[Symbol]
            Atoms to assume false.

        Returns
        -------
        None
        &#39;&#39;&#39;
        self.backend.add_assume(chain(self._add_lits(pos_atoms, True), self._add_lits(neg_atoms, False)))

    def add_atom(self, symbol: Symbol) -&gt; int:
        &#39;&#39;&#39;
        Return a fresh program atom or the atom associated with the given
        symbol.

        If the given symbol does not exist in the atom base, it is added first.
        Such atoms will be used in subsequents calls to ground for
        instantiation.

        Parameters
        ----------
        symbol : Optional[Symbol]=None
            The symbol associated with the atom.

        Returns
        -------
        int
            The program atom representing the atom.
        &#39;&#39;&#39;
        return self.backend.add_atom(symbol)

    def add_external(self, atom: Symbol, value: TruthValue = TruthValue.False_) -&gt; None:
        &#39;&#39;&#39;
        Mark a program atom as external and set its truth value.

        Parameters
        ----------
        atom : Symbol
            The atom to mark as external.
        value : TruthValue=TruthValue.False_
            Optional truth value.

        Returns
        -------
        None

        Notes
        -----
        Can also be used to release an external atom using `TruthValue.Release`.
        &#39;&#39;&#39;
        return self.backend.add_external(self.backend.add_atom(atom), value)

    def add_heuristic(self, atom: Symbol, type_: HeuristicType, bias: int, priority: int,
                      pos_condition: Iterable[Symbol], neg_condition: Iterable[Symbol]) -&gt; None:
        &#39;&#39;&#39;
        Add a heuristic directive to the underlying backend.

        Parameters
        ----------
        atom : Symbol
            Program atom to heuristically modify.
        type_ : HeuristicType
            The type of modification.
        bias : int
            A signed integer.
        priority : int
            An unsigned integer.
        pos_condition : Iterable[Symbol]
            List of program literals forming the positive part of the
            condition.
        neg_condition : Iterable[Symbol]
            List of program literals forming the negated part of the condition.

        Returns
        -------
        None
        &#39;&#39;&#39;
        condition = chain(self._add_lits(pos_condition, True), self._add_lits(neg_condition, False))
        return self.backend.add_heuristic(self.backend.add_atom(atom), type_, bias, priority, condition)

    def add_minimize(self, priority: int, pos_literals: Iterable[Tuple[Symbol, int]],
                     neg_literals: Iterable[Tuple[Symbol, int]]) -&gt; None:
        &#39;&#39;&#39;
        Add a minimize constraint to the underlying backend.

        Parameters
        ----------
        priority : int
            Integer for the priority.
        pos_literals : Iterable[Tuple[Symbol,int]]
            List of pairs of program symbols and weights forming the positive
            part of the condition.
        neg_literals : Iterable[Tuple[Symbol,int]]
            List of pairs of program symbols and weights forming the negated
            part of the condition.

        Returns
        -------
        None
        &#39;&#39;&#39;
        literals = chain(self._add_wlits(pos_literals, True), self._add_wlits(neg_literals, False))
        return self.backend.add_minimize(priority, literals)

    def add_project(self, atoms: Iterable[Symbol]) -&gt; None:
        &#39;&#39;&#39;
        Add a project statement to the underlying backend.

        Parameters
        ----------
        atoms : Iterable[Symbol]
            List of program symbols to project on.

        Returns
        -------
        None
        &#39;&#39;&#39;
        return self.backend.add_project(self._add_lits(atoms, True))

    def add_rule(self, head: Iterable[Symbol] = (), pos_body: Iterable[Symbol] = (), neg_body: Iterable[Symbol] = (),
                 choice: bool = False) -&gt; None:
        &#39;&#39;&#39;
        Add a disjuntive or choice rule to the underlying backend.

        Parameters
        ----------
        head : Iterable[Symbol]
            The program atoms forming the rule head.
        pos_body : Iterable[Symbol]=()
            The program symbols forming the positive body of the rule
        neg_body : Iterable[Symbol]=()
            The program symbols forming the negated body of the rule
        choice : bool=False
            Whether to add a disjunctive or choice rule.

        Returns
        -------
        None

        Notes
        -----
        Integrity constraints and normal rules can be added by using an empty or
        singleton head list, respectively.
        &#39;&#39;&#39;
        body = chain(self._add_lits(pos_body, True), self._add_lits(neg_body, False))
        return self.backend.add_rule(self._add_lits(head, True), body, choice)

    def add_weight_rule(self, head: Iterable[Symbol], lower: int, pos_body: Iterable[Tuple[Symbol, int]],
                        neg_body: Iterable[Tuple[Symbol, int]], choice: bool = False) -&gt; None:
        &#39;&#39;&#39;
        Add a disjunctive or choice rule with one weight constraint with a lower
        bound in the body to the underlying backend.

        Parameters
        ----------
        head : Iterable[int]
            The program atoms forming the rule head.
        lower : int
            The lower bound.
        pos_body : Iterable[Tuple[Symbol,int]]
            The pairs of program symbols and weights forming the elements of the
            positive body of the weight constraint.
        neg_body : Iterable[Tuple[Symbol,int]]
            The pairs of program symbols and weights forming the elements of the
            negative body of the weight constraint.
        choice : bool=False
            Whether to add a disjunctive or choice rule.

        Returns
        -------
        None
        &#39;&#39;&#39;
        body = chain(self._add_wlits(pos_body, True), self._add_wlits(neg_body, False))
        return self.backend.add_weight_rule(self._add_lits(head, True), lower, body, choice)

    def _add_lits(self, atoms: Iterable[Symbol], sign: bool) -&gt; Iterable[int]:
        &#39;&#39;&#39;
        Map the given atoms to program literals with the given sign.
        &#39;&#39;&#39;
        return (_add_sign(self.backend.add_atom(symbol), sign) for symbol in atoms)

    def _add_wlits(self, weighted_symbols: Iterable[Tuple[Symbol, int]], sign: bool):
        &#39;&#39;&#39;
        Map the given weighted atoms to weighted program literals with the
        given sign.
        &#39;&#39;&#39;
        return ((_add_sign(self.backend.add_atom(x), sign), w) for (x, w) in weighted_symbols)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingox.backends.SymbolicBackend"><code class="flex name class">
<span>class <span class="ident">SymbolicBackend</span></span>
<span>(</span><span>backend: clingo.Backend)</span>
</code></dt>
<dd>
<div class="desc"><p>Backend wrapper providing a interface to extend a logic program. It mirrors
the interface of clingo's Backend, but using Symbols rather than integers
to represent literals.</p>
<p>Implements: <code>ContextManager[<a title="clingox.backends.SymbolicBackend" href="#clingox.backends.SymbolicBackend">SymbolicBackend</a>]</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code>clingo.Backend</code>, <code>clingo.Control.backend</code></p>
<h2 id="notes">Notes</h2>
<p>The <code><a title="clingox.backends.SymbolicBackend" href="#clingox.backends.SymbolicBackend">SymbolicBackend</a></code> is a context manager and must be used with Python's
<code>with</code> statement.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows how to add the rules</p>
<pre><code>a :- b, not c.
b.
</code></pre>
<p>to a program:</p>
<pre><code>&gt;&gt;&gt; import clingo
&gt;&gt;&gt; from clingox.backends import SymbolicBackend
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; a = clingo.Function("a")
&gt;&gt;&gt; b = clingo.Function("b")
&gt;&gt;&gt; c = clingo.Function("c")
&gt;&gt;&gt; with SymbolicBackend(ctl.backend()) as symbolic_backend:
        symbolic_backend.add_rule([a], [b], [c])
        symbolic_backend.add_rule([b])
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: a b
SAT
</code></pre>
<p>The <code><a title="clingox.backends.SymbolicBackend" href="#clingox.backends.SymbolicBackend">SymbolicBackend</a></code> can also be used in combination with the <code>Backend</code>
that it wraps. In this case, it is the <code>Backend</code> that must be used with
Python's <code>with</code> statement:</p>
<pre><code>&gt;&gt;&gt; import clingo
&gt;&gt;&gt; from clingox.backends import SymbolicBackend
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; a = clingo.Function("a")
&gt;&gt;&gt; b = clingo.Function("b")
&gt;&gt;&gt; c = clingo.Function("c")
&gt;&gt;&gt; with ctl.backend() as backend:
        symbolic_backend = SymbolicBackend(backend)
        symbolic_backend.add_rule([a], [b], [c])
        atom_b = backend.add_atom(b)
        backend.add_rule([atom_b])
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: a b
SAT
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SymbolicBackend():
    &#39;&#39;&#39;
    Backend wrapper providing a interface to extend a logic program. It mirrors
    the interface of clingo&#39;s Backend, but using Symbols rather than integers
    to represent literals.

    Implements: `ContextManager[SymbolicBackend]`.

    See Also
    --------
    clingo.Backend, clingo.Control.backend

    Notes
    --------
    The `SymbolicBackend` is a context manager and must be used with Python&#39;s
    `with` statement.

    Examples
    --------
    The following example shows how to add the rules

        a :- b, not c.
        b.

    to a program:

        &gt;&gt;&gt; import clingo
        &gt;&gt;&gt; from clingox.backends import SymbolicBackend
        &gt;&gt;&gt; ctl = clingo.Control()
        &gt;&gt;&gt; a = clingo.Function(&#34;a&#34;)
        &gt;&gt;&gt; b = clingo.Function(&#34;b&#34;)
        &gt;&gt;&gt; c = clingo.Function(&#34;c&#34;)
        &gt;&gt;&gt; with SymbolicBackend(ctl.backend()) as symbolic_backend:
                symbolic_backend.add_rule([a], [b], [c])
                symbolic_backend.add_rule([b])
        &gt;&gt;&gt; ctl.solve(on_model=lambda m: print(&#34;Answer: {}&#34;.format(m)))
        Answer: a b
        SAT

    The `SymbolicBackend` can also be used in combination with the `Backend`
    that it wraps. In this case, it is the `Backend` that must be used with
    Python&#39;s `with` statement:

        &gt;&gt;&gt; import clingo
        &gt;&gt;&gt; from clingox.backends import SymbolicBackend
        &gt;&gt;&gt; ctl = clingo.Control()
        &gt;&gt;&gt; a = clingo.Function(&#34;a&#34;)
        &gt;&gt;&gt; b = clingo.Function(&#34;b&#34;)
        &gt;&gt;&gt; c = clingo.Function(&#34;c&#34;)
        &gt;&gt;&gt; with ctl.backend() as backend:
                symbolic_backend = SymbolicBackend(backend)
                symbolic_backend.add_rule([a], [b], [c])
                atom_b = backend.add_atom(b)
                backend.add_rule([atom_b])
        &gt;&gt;&gt; ctl.solve(on_model=lambda m: print(&#34;Answer: {}&#34;.format(m)))
        Answer: a b
        SAT
    &#39;&#39;&#39;
    def __init__(self, backend: Backend):
        self.backend: Backend = backend

    def __enter__(self):
        &#39;&#39;&#39;
        Initialize the backend.

        Returns
        -------
        Backend
            Returns the backend itself.

        Notes
        -----
        Must be called before using the backend.
        &#39;&#39;&#39;
        self.backend.__enter__()
        return self

    def __exit__(self, type_, value, traceback):
        &#39;&#39;&#39;
        Finalize the backend.

        Notes
        -----
        Follows Python&#39;s __exit__ conventions. Does not suppress exceptions.
        &#39;&#39;&#39;
        return self.backend.__exit__(type_, value, traceback)

    def add_acyc_edge(self, node_u: int, node_v: int, pos_condition: Iterable[Symbol],
                      neg_condition: Iterable[Symbol]) -&gt; None:
        &#39;&#39;&#39;
        Add an edge directive to the underlying backend.

        Parameters
        ----------
        node_u : int
            The start node represented as an unsigned integer.
        node_v : int
            The end node represented as an unsigned integer.
        pos_condition : Iterable[Symbol]
            List of program symbols forming positive part of the condition.
        neg_condition : Iterable[Symbol]
            List of program symbols forming negated part of the condition.

        Returns
        -------
        None
        &#39;&#39;&#39;
        condition = chain(self._add_lits(pos_condition, True), self._add_lits(neg_condition, False))
        self.backend.add_acyc_edge(node_u, node_v, condition)

    def add_assume(self, pos_atoms: Iterable[Symbol] = (), neg_atoms: Iterable[Symbol] = ()) -&gt; None:
        &#39;&#39;&#39;
        Add assumptions to the underlying backend.

        Parameters
        ----------
        pos_atoms : Iterable[Symbol]
            Atoms to assume true.
        neg_atoms : Iterable[Symbol]
            Atoms to assume false.

        Returns
        -------
        None
        &#39;&#39;&#39;
        self.backend.add_assume(chain(self._add_lits(pos_atoms, True), self._add_lits(neg_atoms, False)))

    def add_atom(self, symbol: Symbol) -&gt; int:
        &#39;&#39;&#39;
        Return a fresh program atom or the atom associated with the given
        symbol.

        If the given symbol does not exist in the atom base, it is added first.
        Such atoms will be used in subsequents calls to ground for
        instantiation.

        Parameters
        ----------
        symbol : Optional[Symbol]=None
            The symbol associated with the atom.

        Returns
        -------
        int
            The program atom representing the atom.
        &#39;&#39;&#39;
        return self.backend.add_atom(symbol)

    def add_external(self, atom: Symbol, value: TruthValue = TruthValue.False_) -&gt; None:
        &#39;&#39;&#39;
        Mark a program atom as external and set its truth value.

        Parameters
        ----------
        atom : Symbol
            The atom to mark as external.
        value : TruthValue=TruthValue.False_
            Optional truth value.

        Returns
        -------
        None

        Notes
        -----
        Can also be used to release an external atom using `TruthValue.Release`.
        &#39;&#39;&#39;
        return self.backend.add_external(self.backend.add_atom(atom), value)

    def add_heuristic(self, atom: Symbol, type_: HeuristicType, bias: int, priority: int,
                      pos_condition: Iterable[Symbol], neg_condition: Iterable[Symbol]) -&gt; None:
        &#39;&#39;&#39;
        Add a heuristic directive to the underlying backend.

        Parameters
        ----------
        atom : Symbol
            Program atom to heuristically modify.
        type_ : HeuristicType
            The type of modification.
        bias : int
            A signed integer.
        priority : int
            An unsigned integer.
        pos_condition : Iterable[Symbol]
            List of program literals forming the positive part of the
            condition.
        neg_condition : Iterable[Symbol]
            List of program literals forming the negated part of the condition.

        Returns
        -------
        None
        &#39;&#39;&#39;
        condition = chain(self._add_lits(pos_condition, True), self._add_lits(neg_condition, False))
        return self.backend.add_heuristic(self.backend.add_atom(atom), type_, bias, priority, condition)

    def add_minimize(self, priority: int, pos_literals: Iterable[Tuple[Symbol, int]],
                     neg_literals: Iterable[Tuple[Symbol, int]]) -&gt; None:
        &#39;&#39;&#39;
        Add a minimize constraint to the underlying backend.

        Parameters
        ----------
        priority : int
            Integer for the priority.
        pos_literals : Iterable[Tuple[Symbol,int]]
            List of pairs of program symbols and weights forming the positive
            part of the condition.
        neg_literals : Iterable[Tuple[Symbol,int]]
            List of pairs of program symbols and weights forming the negated
            part of the condition.

        Returns
        -------
        None
        &#39;&#39;&#39;
        literals = chain(self._add_wlits(pos_literals, True), self._add_wlits(neg_literals, False))
        return self.backend.add_minimize(priority, literals)

    def add_project(self, atoms: Iterable[Symbol]) -&gt; None:
        &#39;&#39;&#39;
        Add a project statement to the underlying backend.

        Parameters
        ----------
        atoms : Iterable[Symbol]
            List of program symbols to project on.

        Returns
        -------
        None
        &#39;&#39;&#39;
        return self.backend.add_project(self._add_lits(atoms, True))

    def add_rule(self, head: Iterable[Symbol] = (), pos_body: Iterable[Symbol] = (), neg_body: Iterable[Symbol] = (),
                 choice: bool = False) -&gt; None:
        &#39;&#39;&#39;
        Add a disjuntive or choice rule to the underlying backend.

        Parameters
        ----------
        head : Iterable[Symbol]
            The program atoms forming the rule head.
        pos_body : Iterable[Symbol]=()
            The program symbols forming the positive body of the rule
        neg_body : Iterable[Symbol]=()
            The program symbols forming the negated body of the rule
        choice : bool=False
            Whether to add a disjunctive or choice rule.

        Returns
        -------
        None

        Notes
        -----
        Integrity constraints and normal rules can be added by using an empty or
        singleton head list, respectively.
        &#39;&#39;&#39;
        body = chain(self._add_lits(pos_body, True), self._add_lits(neg_body, False))
        return self.backend.add_rule(self._add_lits(head, True), body, choice)

    def add_weight_rule(self, head: Iterable[Symbol], lower: int, pos_body: Iterable[Tuple[Symbol, int]],
                        neg_body: Iterable[Tuple[Symbol, int]], choice: bool = False) -&gt; None:
        &#39;&#39;&#39;
        Add a disjunctive or choice rule with one weight constraint with a lower
        bound in the body to the underlying backend.

        Parameters
        ----------
        head : Iterable[int]
            The program atoms forming the rule head.
        lower : int
            The lower bound.
        pos_body : Iterable[Tuple[Symbol,int]]
            The pairs of program symbols and weights forming the elements of the
            positive body of the weight constraint.
        neg_body : Iterable[Tuple[Symbol,int]]
            The pairs of program symbols and weights forming the elements of the
            negative body of the weight constraint.
        choice : bool=False
            Whether to add a disjunctive or choice rule.

        Returns
        -------
        None
        &#39;&#39;&#39;
        body = chain(self._add_wlits(pos_body, True), self._add_wlits(neg_body, False))
        return self.backend.add_weight_rule(self._add_lits(head, True), lower, body, choice)

    def _add_lits(self, atoms: Iterable[Symbol], sign: bool) -&gt; Iterable[int]:
        &#39;&#39;&#39;
        Map the given atoms to program literals with the given sign.
        &#39;&#39;&#39;
        return (_add_sign(self.backend.add_atom(symbol), sign) for symbol in atoms)

    def _add_wlits(self, weighted_symbols: Iterable[Tuple[Symbol, int]], sign: bool):
        &#39;&#39;&#39;
        Map the given weighted atoms to weighted program literals with the
        given sign.
        &#39;&#39;&#39;
        return ((_add_sign(self.backend.add_atom(x), sign), w) for (x, w) in weighted_symbols)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="clingox.backends.SymbolicBackend.add_acyc_edge"><code class="name flex">
<span>def <span class="ident">add_acyc_edge</span></span>(<span>self, node_u: int, node_v: int, pos_condition: Iterable[clingo.Symbol], neg_condition: Iterable[clingo.Symbol]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add an edge directive to the underlying backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_u</code></strong> :&ensp;<code>int</code></dt>
<dd>The start node represented as an unsigned integer.</dd>
<dt><strong><code>node_v</code></strong> :&ensp;<code>int</code></dt>
<dd>The end node represented as an unsigned integer.</dd>
<dt><strong><code>pos_condition</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>List of program symbols forming positive part of the condition.</dd>
<dt><strong><code>neg_condition</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>List of program symbols forming negated part of the condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_acyc_edge(self, node_u: int, node_v: int, pos_condition: Iterable[Symbol],
                  neg_condition: Iterable[Symbol]) -&gt; None:
    &#39;&#39;&#39;
    Add an edge directive to the underlying backend.

    Parameters
    ----------
    node_u : int
        The start node represented as an unsigned integer.
    node_v : int
        The end node represented as an unsigned integer.
    pos_condition : Iterable[Symbol]
        List of program symbols forming positive part of the condition.
    neg_condition : Iterable[Symbol]
        List of program symbols forming negated part of the condition.

    Returns
    -------
    None
    &#39;&#39;&#39;
    condition = chain(self._add_lits(pos_condition, True), self._add_lits(neg_condition, False))
    self.backend.add_acyc_edge(node_u, node_v, condition)</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_assume"><code class="name flex">
<span>def <span class="ident">add_assume</span></span>(<span>self, pos_atoms: Iterable[clingo.Symbol] = (), neg_atoms: Iterable[clingo.Symbol] = ()) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add assumptions to the underlying backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pos_atoms</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>Atoms to assume true.</dd>
<dt><strong><code>neg_atoms</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>Atoms to assume false.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_assume(self, pos_atoms: Iterable[Symbol] = (), neg_atoms: Iterable[Symbol] = ()) -&gt; None:
    &#39;&#39;&#39;
    Add assumptions to the underlying backend.

    Parameters
    ----------
    pos_atoms : Iterable[Symbol]
        Atoms to assume true.
    neg_atoms : Iterable[Symbol]
        Atoms to assume false.

    Returns
    -------
    None
    &#39;&#39;&#39;
    self.backend.add_assume(chain(self._add_lits(pos_atoms, True), self._add_lits(neg_atoms, False)))</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_atom"><code class="name flex">
<span>def <span class="ident">add_atom</span></span>(<span>self, symbol: clingo.Symbol) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return a fresh program atom or the atom associated with the given
symbol.</p>
<p>If the given symbol does not exist in the atom base, it is added first.
Such atoms will be used in subsequents calls to ground for
instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>Optional[Symbol]=None</code></dt>
<dd>The symbol associated with the atom.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The program atom representing the atom.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_atom(self, symbol: Symbol) -&gt; int:
    &#39;&#39;&#39;
    Return a fresh program atom or the atom associated with the given
    symbol.

    If the given symbol does not exist in the atom base, it is added first.
    Such atoms will be used in subsequents calls to ground for
    instantiation.

    Parameters
    ----------
    symbol : Optional[Symbol]=None
        The symbol associated with the atom.

    Returns
    -------
    int
        The program atom representing the atom.
    &#39;&#39;&#39;
    return self.backend.add_atom(symbol)</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_external"><code class="name flex">
<span>def <span class="ident">add_external</span></span>(<span>self, atom: clingo.Symbol, value: clingo.TruthValue = False_) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mark a program atom as external and set its truth value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>Symbol</code></dt>
<dd>The atom to mark as external.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>TruthValue=TruthValue.False_</code></dt>
<dd>Optional truth value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Can also be used to release an external atom using <code>TruthValue.Release</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_external(self, atom: Symbol, value: TruthValue = TruthValue.False_) -&gt; None:
    &#39;&#39;&#39;
    Mark a program atom as external and set its truth value.

    Parameters
    ----------
    atom : Symbol
        The atom to mark as external.
    value : TruthValue=TruthValue.False_
        Optional truth value.

    Returns
    -------
    None

    Notes
    -----
    Can also be used to release an external atom using `TruthValue.Release`.
    &#39;&#39;&#39;
    return self.backend.add_external(self.backend.add_atom(atom), value)</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_heuristic"><code class="name flex">
<span>def <span class="ident">add_heuristic</span></span>(<span>self, atom: clingo.Symbol, type_: clingo.HeuristicType, bias: int, priority: int, pos_condition: Iterable[clingo.Symbol], neg_condition: Iterable[clingo.Symbol]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add a heuristic directive to the underlying backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>Symbol</code></dt>
<dd>Program atom to heuristically modify.</dd>
<dt><strong><code>type_</code></strong> :&ensp;<code>HeuristicType</code></dt>
<dd>The type of modification.</dd>
<dt><strong><code>bias</code></strong> :&ensp;<code>int</code></dt>
<dd>A signed integer.</dd>
<dt><strong><code>priority</code></strong> :&ensp;<code>int</code></dt>
<dd>An unsigned integer.</dd>
<dt><strong><code>pos_condition</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>List of program literals forming the positive part of the
condition.</dd>
<dt><strong><code>neg_condition</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>List of program literals forming the negated part of the condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_heuristic(self, atom: Symbol, type_: HeuristicType, bias: int, priority: int,
                  pos_condition: Iterable[Symbol], neg_condition: Iterable[Symbol]) -&gt; None:
    &#39;&#39;&#39;
    Add a heuristic directive to the underlying backend.

    Parameters
    ----------
    atom : Symbol
        Program atom to heuristically modify.
    type_ : HeuristicType
        The type of modification.
    bias : int
        A signed integer.
    priority : int
        An unsigned integer.
    pos_condition : Iterable[Symbol]
        List of program literals forming the positive part of the
        condition.
    neg_condition : Iterable[Symbol]
        List of program literals forming the negated part of the condition.

    Returns
    -------
    None
    &#39;&#39;&#39;
    condition = chain(self._add_lits(pos_condition, True), self._add_lits(neg_condition, False))
    return self.backend.add_heuristic(self.backend.add_atom(atom), type_, bias, priority, condition)</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_minimize"><code class="name flex">
<span>def <span class="ident">add_minimize</span></span>(<span>self, priority: int, pos_literals: Iterable[Tuple[clingo.Symbol, int]], neg_literals: Iterable[Tuple[clingo.Symbol, int]]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add a minimize constraint to the underlying backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>priority</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer for the priority.</dd>
<dt><strong><code>pos_literals</code></strong> :&ensp;<code>Iterable[Tuple[Symbol,int]]</code></dt>
<dd>List of pairs of program symbols and weights forming the positive
part of the condition.</dd>
<dt><strong><code>neg_literals</code></strong> :&ensp;<code>Iterable[Tuple[Symbol,int]]</code></dt>
<dd>List of pairs of program symbols and weights forming the negated
part of the condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_minimize(self, priority: int, pos_literals: Iterable[Tuple[Symbol, int]],
                 neg_literals: Iterable[Tuple[Symbol, int]]) -&gt; None:
    &#39;&#39;&#39;
    Add a minimize constraint to the underlying backend.

    Parameters
    ----------
    priority : int
        Integer for the priority.
    pos_literals : Iterable[Tuple[Symbol,int]]
        List of pairs of program symbols and weights forming the positive
        part of the condition.
    neg_literals : Iterable[Tuple[Symbol,int]]
        List of pairs of program symbols and weights forming the negated
        part of the condition.

    Returns
    -------
    None
    &#39;&#39;&#39;
    literals = chain(self._add_wlits(pos_literals, True), self._add_wlits(neg_literals, False))
    return self.backend.add_minimize(priority, literals)</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_project"><code class="name flex">
<span>def <span class="ident">add_project</span></span>(<span>self, atoms: Iterable[clingo.Symbol]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add a project statement to the underlying backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atoms</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>List of program symbols to project on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_project(self, atoms: Iterable[Symbol]) -&gt; None:
    &#39;&#39;&#39;
    Add a project statement to the underlying backend.

    Parameters
    ----------
    atoms : Iterable[Symbol]
        List of program symbols to project on.

    Returns
    -------
    None
    &#39;&#39;&#39;
    return self.backend.add_project(self._add_lits(atoms, True))</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_rule"><code class="name flex">
<span>def <span class="ident">add_rule</span></span>(<span>self, head: Iterable[clingo.Symbol] = (), pos_body: Iterable[clingo.Symbol] = (), neg_body: Iterable[clingo.Symbol] = (), choice: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add a disjuntive or choice rule to the underlying backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code>Iterable[Symbol]</code></dt>
<dd>The program atoms forming the rule head.</dd>
<dt><strong><code>pos_body</code></strong> :&ensp;<code>Iterable[Symbol]=()</code></dt>
<dd>The program symbols forming the positive body of the rule</dd>
<dt><strong><code>neg_body</code></strong> :&ensp;<code>Iterable[Symbol]=()</code></dt>
<dd>The program symbols forming the negated body of the rule</dd>
<dt><strong><code>choice</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Whether to add a disjunctive or choice rule.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Integrity constraints and normal rules can be added by using an empty or
singleton head list, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_rule(self, head: Iterable[Symbol] = (), pos_body: Iterable[Symbol] = (), neg_body: Iterable[Symbol] = (),
             choice: bool = False) -&gt; None:
    &#39;&#39;&#39;
    Add a disjuntive or choice rule to the underlying backend.

    Parameters
    ----------
    head : Iterable[Symbol]
        The program atoms forming the rule head.
    pos_body : Iterable[Symbol]=()
        The program symbols forming the positive body of the rule
    neg_body : Iterable[Symbol]=()
        The program symbols forming the negated body of the rule
    choice : bool=False
        Whether to add a disjunctive or choice rule.

    Returns
    -------
    None

    Notes
    -----
    Integrity constraints and normal rules can be added by using an empty or
    singleton head list, respectively.
    &#39;&#39;&#39;
    body = chain(self._add_lits(pos_body, True), self._add_lits(neg_body, False))
    return self.backend.add_rule(self._add_lits(head, True), body, choice)</code></pre>
</details>
</dd>
<dt id="clingox.backends.SymbolicBackend.add_weight_rule"><code class="name flex">
<span>def <span class="ident">add_weight_rule</span></span>(<span>self, head: Iterable[clingo.Symbol], lower: int, pos_body: Iterable[Tuple[clingo.Symbol, int]], neg_body: Iterable[Tuple[clingo.Symbol, int]], choice: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add a disjunctive or choice rule with one weight constraint with a lower
bound in the body to the underlying backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>The program atoms forming the rule head.</dd>
<dt><strong><code>lower</code></strong> :&ensp;<code>int</code></dt>
<dd>The lower bound.</dd>
<dt><strong><code>pos_body</code></strong> :&ensp;<code>Iterable[Tuple[Symbol,int]]</code></dt>
<dd>The pairs of program symbols and weights forming the elements of the
positive body of the weight constraint.</dd>
<dt><strong><code>neg_body</code></strong> :&ensp;<code>Iterable[Tuple[Symbol,int]]</code></dt>
<dd>The pairs of program symbols and weights forming the elements of the
negative body of the weight constraint.</dd>
<dt><strong><code>choice</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Whether to add a disjunctive or choice rule.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_weight_rule(self, head: Iterable[Symbol], lower: int, pos_body: Iterable[Tuple[Symbol, int]],
                    neg_body: Iterable[Tuple[Symbol, int]], choice: bool = False) -&gt; None:
    &#39;&#39;&#39;
    Add a disjunctive or choice rule with one weight constraint with a lower
    bound in the body to the underlying backend.

    Parameters
    ----------
    head : Iterable[int]
        The program atoms forming the rule head.
    lower : int
        The lower bound.
    pos_body : Iterable[Tuple[Symbol,int]]
        The pairs of program symbols and weights forming the elements of the
        positive body of the weight constraint.
    neg_body : Iterable[Tuple[Symbol,int]]
        The pairs of program symbols and weights forming the elements of the
        negative body of the weight constraint.
    choice : bool=False
        Whether to add a disjunctive or choice rule.

    Returns
    -------
    None
    &#39;&#39;&#39;
    body = chain(self._add_wlits(pos_body, True), self._add_wlits(neg_body, False))
    return self.backend.add_weight_rule(self._add_lits(head, True), lower, body, choice)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clingox" href="index.html">clingox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingox.backends.SymbolicBackend" href="#clingox.backends.SymbolicBackend">SymbolicBackend</a></code></h4>
<ul class="two-column">
<li><code><a title="clingox.backends.SymbolicBackend.add_acyc_edge" href="#clingox.backends.SymbolicBackend.add_acyc_edge">add_acyc_edge</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_assume" href="#clingox.backends.SymbolicBackend.add_assume">add_assume</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_atom" href="#clingox.backends.SymbolicBackend.add_atom">add_atom</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_external" href="#clingox.backends.SymbolicBackend.add_external">add_external</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_heuristic" href="#clingox.backends.SymbolicBackend.add_heuristic">add_heuristic</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_minimize" href="#clingox.backends.SymbolicBackend.add_minimize">add_minimize</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_project" href="#clingox.backends.SymbolicBackend.add_project">add_project</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_rule" href="#clingox.backends.SymbolicBackend.add_rule">add_rule</a></code></li>
<li><code><a title="clingox.backends.SymbolicBackend.add_weight_rule" href="#clingox.backends.SymbolicBackend.add_weight_rule">add_weight_rule</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>