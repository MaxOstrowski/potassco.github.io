---
layout: page
title: clingo API documentation
description: The clingo-5.5.0 module …
css:
- /css/pdoc.css
- /css/github.min.css
permalink: /clingo/python-api/5.5//
---
<main>
<article id="content">
<header>
<h1 class="title"><code>clingo</code> module</h1>
</header>
<section id="section-intro">
<p>The clingo-5.5.0 module.</p>
<p>This module provides functions and classes to control the grounding and solving
process.</p>
<p>If the clingo application is build with Python support, clingo will also be
able to execute Python code embedded in logic programs.
Functions defined in a
Python script block are callable during the instantiation process using
<code>@</code>-syntax.
The default grounding/solving process can be customized if a main
function is provided.</p>
<p>Note that gringo's precomputed terms (terms without variables and interpreted
functions), called symbols in the following, are wrapped in the Symbol class.
Furthermore, strings, numbers, and tuples can be passed wherever a symbol is
expected - they are automatically converted into a Symbol object.
Functions
called during the grounding process from the logic program must either return a
symbol or a sequence of symbols.
If a sequence is returned, the corresponding
<code>@</code>-term is successively substituted by the values in the sequence.</p>
<h2 id="examples">Examples</h2>
<p>The first example shows how to use the clingo module from Python.</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; class Context:
...     def id(self, x):
...         return x
...     def seq(self, x, y):
...         return [x, y]
...
&gt;&gt;&gt; def on_model(m):
...     print (m)
...
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; ctl.add("base", [], """\
... p(@id(10)).
... q(@seq(1,2)).
... """)
&gt;&gt;&gt; ctl.ground([("base", [])], context=Context())
&gt;&gt;&gt; ctl.solve(on_model=on_model)
p(10) q(1) q(2)
SAT
</code></pre>
<p>The second example shows how to use Python code from clingo.</p>
<pre><code class="hljs python">#script (python)

import clingo

class Context:
    def id(x):
        return x

    def seq(x, y):
        return [x, y]

def main(prg):
    prg.ground([("base", [])], context=Context())
    prg.solve()

#end.

p(@id(10)).
q(@seq(1,2)).
</code></pre>
</section>
<section id="section-toc">
<h2 id="header-toc" class="section-toc">Overview</h2>
<nav class="sidebar">
<ul class="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul class="">
<li><code><a title="clingo.ast" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}">clingo.ast</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="two-column">
<li><code><a title="clingo.Infimum" href="#clingo.Infimum">Infimum</a></code></li>
<li><code><a title="clingo.Supremum" href="#clingo.Supremum">Supremum</a></code></li>
<li><code><a title="clingo.__version__" href="#clingo.__version__">__version__</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="clingo.Function" href="#clingo.Function">Function</a></code></li>
<li><code><a title="clingo.Number" href="#clingo.Number">Number</a></code></li>
<li><code><a title="clingo.String" href="#clingo.String">String</a></code></li>
<li><code><a title="clingo.Tuple_" href="#clingo.Tuple_">Tuple_</a></code></li>
<li><code><a title="clingo.clingo_main" href="#clingo.clingo_main">clingo_main</a></code></li>
<li><code><a title="clingo.parse_program" href="#clingo.parse_program">parse_program</a></code></li>
<li><code><a title="clingo.parse_term" href="#clingo.parse_term">parse_term</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul class="two-column">
<li><code><a title="clingo.Application" href="#clingo.Application">Application</a></code></li>
<li><code><a title="clingo.ApplicationOptions" href="#clingo.ApplicationOptions">ApplicationOptions</a></code></li>
<li><code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code></li>
<li><code><a title="clingo.Backend" href="#clingo.Backend">Backend</a></code></li>
<li><code><a title="clingo.Configuration" href="#clingo.Configuration">Configuration</a></code></li>
<li><code><a title="clingo.Control" href="#clingo.Control">Control</a></code></li>
<li><code><a title="clingo.Flag" href="#clingo.Flag">Flag</a></code></li>
<li><code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></li>
<li><code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></li>
<li><code><a title="clingo.Model" href="#clingo.Model">Model</a></code></li>
<li><code><a title="clingo.ModelType" href="#clingo.ModelType">ModelType</a></code></li>
<li><code><a title="clingo.Observer" href="#clingo.Observer">Observer</a></code></li>
<li><code><a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a></code></li>
<li><code><a title="clingo.PropagateControl" href="#clingo.PropagateControl">PropagateControl</a></code></li>
<li><code><a title="clingo.PropagateInit" href="#clingo.PropagateInit">PropagateInit</a></code></li>
<li><code><a title="clingo.Propagator" href="#clingo.Propagator">Propagator</a></code></li>
<li><code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code></li>
<li><code><a title="clingo.SolveControl" href="#clingo.SolveControl">SolveControl</a></code></li>
<li><code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code></li>
<li><code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code></li>
<li><code><a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a></code></li>
<li><code><a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a></code></li>
<li><code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></li>
<li><code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></li>
<li><code><a title="clingo.SymbolicAtom" href="#clingo.SymbolicAtom">SymbolicAtom</a></code></li>
<li><code><a title="clingo.SymbolicAtomIter" href="#clingo.SymbolicAtomIter">SymbolicAtomIter</a></code></li>
<li><code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code></li>
<li><code><a title="clingo.TheoryAtom" href="#clingo.TheoryAtom">TheoryAtom</a></code></li>
<li><code><a title="clingo.TheoryAtomIter" href="#clingo.TheoryAtomIter">TheoryAtomIter</a></code></li>
<li><code><a title="clingo.TheoryElement" href="#clingo.TheoryElement">TheoryElement</a></code></li>
<li><code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code></li>
<li><code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></li>
<li><code><a title="clingo.Trail" href="#clingo.Trail">Trail</a></code></li>
<li><code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code></li>
</ul>
</li>
</ul>
</nav>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="clingo.ast" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}">clingo.ast</a></code></dt>
<dd>
<section class="desc"><p>The clingo.ast-5.5.0 module …</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="clingo.Infimum"><code class="name">var <span class="ident">Infimum</span><span> : <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span></code></dt>
<dd>
<section class="desc"><p>Represents a symbol of type <code><a title="clingo.SymbolType.Infimum" href="#clingo.SymbolType.Infimum">SymbolType.Infimum</a></code>.</p></section>
</dd>
<dt id="clingo.Supremum"><code class="name">var <span class="ident">Supremum</span><span> : <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span></code></dt>
<dd>
<section class="desc"><p>Represents a symbol of type <code><a title="clingo.SymbolType.Supremum" href="#clingo.SymbolType.Supremum">SymbolType.Supremum</a></code>.</p></section>
</dd>
<dt id="clingo.__version__"><code class="name">var <span class="ident">__version__</span><span> : <code>str</code></span></code></dt>
<dd>
<section class="desc"><p>Version of the clingo module (<code>'5.5.0'</code>).</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clingo.Function"><code class="name flex">
<span>def <span class="ident">Function</span></span><span>(name:<code>str</code>, arguments:<code>Iterable</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]=[], positive:<code>bool</code>=<code>True</code>) -> <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>Construct a function symbol.</p>
<p>This includes constants and tuples. Constants have an empty argument list and
tuples have an empty name. Functions can represent classically negated atoms.
Argument <code>positive</code> has to be set to false to represent such atoms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the function (empty for tuples).</dd>
<dt><strong><code>arguments</code></strong> :&ensp;<code>Iterable[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>] = []</code></dt>
<dd>The arguments in form of a list of symbols.</dd>
<dt><strong><code>positive</code></strong> :&ensp;<code>bool = True</code></dt>
<dd>The sign of the function (tuples must not have signs).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
</dl></section>
</dd>
<dt id="clingo.Number"><code class="name flex">
<span>def <span class="ident">Number</span></span><span>(number:<code>int</code>) -> <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>Construct a numeric symbol given a number.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code></dt>
<dd>The given number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
</dl></section>
</dd>
<dt id="clingo.String"><code class="name flex">
<span>def <span class="ident">String</span></span><span>(string:<code>str</code>) -> <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>Construct a string symbol given a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>The given string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
</dl></section>
</dd>
<dt id="clingo.Tuple_"><code class="name flex">
<span>def <span class="ident">Tuple_</span></span><span>(arguments:<code>Iterable</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]) -> <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>A shortcut for <code>Function("", arguments)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arguments</code></strong> :&ensp;<code>Iterable[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>]</code></dt>
<dd>The arguments in form of a list of symbols.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Function" href="#clingo.Function">Function()</a></code></p></section>
</dd>
<dt id="clingo.clingo_main"><code class="name flex">
<span>def <span class="ident">clingo_main</span></span><span>(application:<code><a title="clingo.Application" href="#clingo.Application">Application</a></code>, files:<code>Iterable</code>[<code>str</code>]=[]) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Runs the given application using clingo's default output and signal handling.</p>
<p>The application can overwrite clingo's default behaviour by registering
additional options and overriding its default main function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>application</code></strong> :&ensp;<code><a title="clingo.Application" href="#clingo.Application">Application</a></code></dt>
<dd>The Application object (see notes).</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The files to pass to the main function of the application.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The exit code of the application.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The main function of the <code><a title="clingo.Application" href="#clingo.Application">Application</a></code> interface has to be implemented. All
other members are optional.</p>
<h2 id="examples">Examples</h2>
<p>The following example reproduces the default clingo application:</p>
<pre><code class="hljs python">import sys
import clingo

class Application(clingo.Application):
    def __init__(self, name):
        self.program_name = name

    def main(self, ctl, files):
        if len(files) &gt; 0:
            for f in files:
                ctl.load(f)
        else:
            ctl.load("-")
        ctl.ground([("base", [])])
        ctl.solve()

clingo.clingo_main(Application(sys.argv[0]), sys.argv[1:])
</code></pre></section>
</dd>
<dt id="clingo.parse_program"><code class="name flex">
<span>def <span class="ident">parse_program</span></span><span>(program:<code>str</code>, callback:<code>Callable</code>[[<code><a title="clingo.ast.AST" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}#clingo.ast.AST">AST</a></code>],<code>None</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Parse the given program and return an abstract syntax tree for each statement
via a callback.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>program</code></strong> :&ensp;<code>str</code></dt>
<dd>String representation of the program.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable[[<a title="clingo.ast.AST" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}#clingo.ast.AST">AST</a>], None]</code></dt>
<dd>Callable taking an ast as argument.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a></code></p></section>
</dd>
<dt id="clingo.parse_term"><code class="name flex">
<span>def <span class="ident">parse_term</span></span><span>(string:<code>str</code>, logger:<code>Callable</code>[[<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code>,<code>str</code>],<code>None</code>]=<code>None</code>, message_limit:<code>int</code>=20) -> <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>Parse the given string using gringo's term parser for ground terms.</p>
<p>The function also evaluates arithmetic functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>The string to be parsed.</dd>
<dt><strong><code>logger</code></strong> :&ensp;<code>Callable[[<a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a>,str],None] = None</code></dt>
<dd>Function to intercept messages normally printed to standard error.</dd>
<dt><strong><code>message_limit</code></strong> :&ensp;<code>int = 20</code></dt>
<dd>Maximum number of messages passed to the logger.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; clingo.parse_term('p(1+2)')
p(3)
</code></pre></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingo.Application"><code class="flex name class">
<span>class <span class="ident">Application</span><span>
</code></dt>
<dd>
<section class="desc"><p>Interface that has to be implemented to customize clingo.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>program_name</code></strong> :&ensp;<code>str = 'clingo'</code></dt>
<dd>Optional program name to be used in the help output.</dd>
<dt><strong><code>message_limit</code></strong> :&ensp;<code>int = 20</code></dt>
<dd>Maximum number of messages passed to the logger.</dd>
</dl></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.Application.logger"><code class="name flex">
<span>def <span class="ident">logger</span></span><span>(self, code:<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code>, message:<code>str</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Function to intercept messages normally printed to standard error.</p>
<p>By default, messages are printed to stdandard error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>The message code.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The message string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>This function should not raise exceptions.</p></section>
</dd>
<dt id="clingo.Application.main"><code class="name flex">
<span>@abstractmethod def <span class="ident">main</span></span><span>(self, control:<code><a title="clingo.Control" href="#clingo.Control">Control</a></code>, files:<code>Sequence</code>[<code>str</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Function to replace clingo's default main function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>control</code></strong> :&ensp;<code><a title="clingo.Control" href="#clingo.Control">Control</a></code></dt>
<dd>The main control object.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>Sequence[str]</code></dt>
<dd>The files passed to clingo_main.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Application.register_options"><code class="name flex">
<span>def <span class="ident">register_options</span></span><span>(self, options:<code><a title="clingo.ApplicationOptions" href="#clingo.ApplicationOptions">ApplicationOptions</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Function to register custom options.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code><a title="clingo.ApplicationOptions" href="#clingo.ApplicationOptions">ApplicationOptions</a></code></dt>
<dd>Object to register additional options</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Application.validate_options"><code class="name flex">
<span>def <span class="ident">validate_options</span></span><span>(self) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Function to validate custom options.</p>
<p>This function should return false or throw an exception if option
validation fails.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.ApplicationOptions"><code class="flex name class">
<span>class <span class="ident">ApplicationOptions</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object to add custom options to a clingo based application.</p></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.ApplicationOptions.add"><code class="name flex">
<span>def <span class="ident">add</span></span><span>(self, group:<code>str</code>, option:<code>str</code>, description:<code>str</code>, parser:<code>Callable</code>[[<code>str</code>],<code>bool</code>], multi:<code>bool</code>=<code>False</code>, argument:<code>str</code>=<code>None</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add an option that is processed with a custom parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>group</code></strong> :&ensp;<code>str</code></dt>
<dd>Options are grouped into sections as given by this string.</dd>
<dt><strong><code>option</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter option specifies the name(s) of the option. For example,
<code>"ping,p"</code> adds the short option <code>-p</code> and its long form <code>--ping</code>. It is
also possible to associate an option with a help level by adding <code>",@l"</code> to
the option specification. Options with a level greater than zero are only
shown if the argument to help is greater or equal to <code>l</code>.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>The description of the option shown in the help output.</dd>
<dt><strong><code>parser</code></strong> :&ensp;<code>Callable[[str], bool]</code></dt>
<dd>An option parser is a function that takes a string as input and returns
true or false depending on whether the option was parsed successively.</dd>
<dt><strong><code>multi</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Whether the option can appear multiple times on the command-line.</dd>
<dt><strong><code>argument</code></strong> :&ensp;<code>str=None</code></dt>
<dd>Optional string to change the value name in the generated help.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>An error is raised if an option with the same name already exists.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The parser also has to take care of storing the semantic value of the option
somewhere.</p></section>
</dd>
<dt id="clingo.ApplicationOptions.add_flag"><code class="name flex">
<span>def <span class="ident">add_flag</span></span><span>(self, group:<code>str</code>, option:<code>str</code>, description:<code>str</code>, target:<code><a title="clingo.Flag" href="#clingo.Flag">Flag</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add an option that is a simple flag.</p>
<p>This function is similar to <code><a title="clingo.ApplicationOptions.add" href="#clingo.ApplicationOptions.add">ApplicationOptions.add()</a></code> but simpler because
it only supports flags, which do not have values. Note that the target
parameter must be of type Flag, which is set to true if the flag is passed on
the command line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>group</code></strong> :&ensp;<code>str</code></dt>
<dd>Options are grouped into sections as given by this string.</dd>
<dt><strong><code>option</code></strong> :&ensp;<code>str</code></dt>
<dd>Same as for <code><a title="clingo.ApplicationOptions.add" href="#clingo.ApplicationOptions.add">ApplicationOptions.add()</a></code>.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>The description of the option shown in the help output.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a title="clingo.Flag" href="#clingo.Flag">Flag</a></code></dt>
<dd>The object that receives the value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.Assignment"><code class="flex name class">
<span>class <span class="ident">Assignment</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object to inspect the (parital) assignment of an associated solver.</p>
<p>Assigns truth values to solver literals.
Each solver literal is either true,
false, or undefined, represented by the Python constants <code>True</code>, <code>False</code>, or
<code>None</code>, respectively.</p>
<p>This class implements <code>Sequence[int]</code> to access the (positive)
literals in the assignment.</p>
<p>Implements: <code>Sequence[int]</code>.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.Assignment.decision_level"><code class="name">var <span class="ident">decision_level</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The current decision level.</p></section>
</dd>
<dt id="clingo.Assignment.has_conflict"><code class="name">var <span class="ident">has_conflict</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>True if the assignment is conflicting.</p></section>
</dd>
<dt id="clingo.Assignment.is_total"><code class="name">var <span class="ident">is_total</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>Whether the assignment is total.</p></section>
</dd>
<dt id="clingo.Assignment.root_level"><code class="name">var <span class="ident">root_level</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The current root level.</p></section>
</dd>
<dt id="clingo.Assignment.trail"><code class="name">var <span class="ident">trail</span><span> : <code><a title="clingo.Trail" href="#clingo.Trail">Trail</a></code></span></code></dt>
<dd>
<section class="desc"><p>The trail of assigned literals.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.Assignment.decision"><code class="name flex">
<span>def <span class="ident">decision</span></span><span>(self, level:<code>int</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Return the decision literal of the given level.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
</dl></section>
</dd>
<dt id="clingo.Assignment.has_literal"><code class="name flex">
<span>def <span class="ident">has_literal</span></span><span>(self, literal:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Determine if the given literal is valid in this solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
</dl></section>
</dd>
<dt id="clingo.Assignment.is_false"><code class="name flex">
<span>def <span class="ident">is_false</span></span><span>(self, literal:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Determine if the literal is false.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
</dl></section>
</dd>
<dt id="clingo.Assignment.is_fixed"><code class="name flex">
<span>def <span class="ident">is_fixed</span></span><span>(self, literal:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Determine if the literal is assigned on the top level.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
</dl></section>
</dd>
<dt id="clingo.Assignment.is_true"><code class="name flex">
<span>def <span class="ident">is_true</span></span><span>(self, literal:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Determine if the literal is true.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
</dl></section>
</dd>
<dt id="clingo.Assignment.level"><code class="name flex">
<span>def <span class="ident">level</span></span><span>(self, literal:<code>int</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>The decision level of the given literal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>Note that the returned value is only meaningful if the literal is assigned -
i.e., <code>value(lit) is not None</code>.</p></section>
</dd>
<dt id="clingo.Assignment.value"><code class="name flex">
<span>def <span class="ident">value</span></span><span>(self, literal) -> <code>Optional</code>[<code>bool</code>]</span>
</code></dt>
<dd>
<section class="desc"><p>Get the truth value of the given literal or <code>None</code> if it has none.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[bool]</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.Backend"><code class="flex name class">
<span>class <span class="ident">Backend</span><span>
</code></dt>
<dd>
<section class="desc"><p>Backend object providing a low level interface to extend a logic program.</p>
<p>This class allows for adding statements in ASPIF format.</p>
<p>Implements: <code>ContextManager[<a title="clingo.Backend" href="#clingo.Backend">Backend</a>]</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.backend" href="#clingo.Control.backend">Control.backend()</a></code></p>
<h2 id="notes">Notes</h2>
<p>The <code><a title="clingo.Backend" href="#clingo.Backend">Backend</a></code> is a context manager and must be used with Python's <code>with</code>
statement.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows how to add a fact to a program:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; sym_a = clingo.Function("a")
&gt;&gt;&gt; with ctl.backend() as backend:
...     atm_a = backend.add_atom(sym_a)
...     backend.add_rule([atm_a])
...
&gt;&gt;&gt; ctl.symbolic_atoms[sym_a].is_fact
True
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: a
SAT
</code></pre></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.Backend.add_acyc_edge"><code class="name flex">
<span>def <span class="ident">add_acyc_edge</span></span><span>(self, node_u:<code>int</code>, node_v:<code>int</code>, condition:<code>Iterable</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add an edge directive to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_u</code></strong> :&ensp;<code>int</code></dt>
<dd>The start node represented as an unsigned integer.</dd>
<dt><strong><code>node_v</code></strong> :&ensp;<code>int</code></dt>
<dd>The end node represented as an unsigned integer.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>List of program literals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Backend.add_assume"><code class="name flex">
<span>def <span class="ident">add_assume</span></span><span>(self, literals:<code>Iterable</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add assumptions to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literals</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>The list of literals to assume true.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Backend.add_atom"><code class="name flex">
<span>def <span class="ident">add_atom</span></span><span>(self, symbol:<code>Optional</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]=<code>None</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Return a fresh program atom or the atom associated with the given symbol.</p>
<p>If the given symbol does not exist in the atom base, it is added first. Such
atoms will be used in subequents calls to ground for instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>Optional[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>]=None</code></dt>
<dd>The symbol associated with the atom.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The program atom representing the atom.</dd>
</dl></section>
</dd>
<dt id="clingo.Backend.add_external"><code class="name flex">
<span>def <span class="ident">add_external</span></span><span>(self, atom:<code>int</code>, value:<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code>=<code><a title="clingo.TruthValue.False_" href="#clingo.TruthValue.False_">TruthValue.False_</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Mark a program atom as external optionally fixing its truth value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>int</code></dt>
<dd>The program atom to mark as external.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a>=<a title="clingo.TruthValue.False_" href="#clingo.TruthValue.False_">TruthValue.False_</a></code></dt>
<dd>Optional truth value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>Can also be used to release an external atom using <code><a title="clingo.TruthValue.Release" href="#clingo.TruthValue.Release">TruthValue.Release</a></code>.</p></section>
</dd>
<dt id="clingo.Backend.add_heuristic"><code class="name flex">
<span>def <span class="ident">add_heuristic</span></span><span>(self, atom:<code>int</code>, type:<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code>, bias:<code>int</code>, priority:<code>int</code>, condition:<code>Iterable</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a heuristic directive to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>int</code></dt>
<dd>Program atom to heuristically modify.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>The type of modification.</dd>
<dt><strong><code>bias</code></strong> :&ensp;<code>int</code></dt>
<dd>A signed integer.</dd>
<dt><strong><code>priority</code></strong> :&ensp;<code>int</code></dt>
<dd>An unsigned integer.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>List of program literals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Backend.add_minimize"><code class="name flex">
<span>def <span class="ident">add_minimize</span></span><span>(self, priority:<code>int</code>, literals:<code>Iterable</code>[<code>Tuple</code>[<code>int</code>,<code>int</code>]]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a minimize constraint to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>priority</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer for the priority.</dd>
<dt><strong><code>literals</code></strong> :&ensp;<code>Iterable[Tuple[int,int]]</code></dt>
<dd>List of pairs of program literals and weights.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Backend.add_project"><code class="name flex">
<span>def <span class="ident">add_project</span></span><span>(self, atoms:<code>Iterable</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a project statement to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atoms</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>List of program atoms to project on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Backend.add_rule"><code class="name flex">
<span>def <span class="ident">add_rule</span></span><span>(self, head:<code>Iterable</code>[<code>int</code>], body:<code>Iterable</code>[<code>int</code>]=[], choice:<code>bool</code>=<code>False</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a disjuntive or choice rule to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>The program atoms forming the rule head.</dd>
<dt><strong><code>body</code></strong> :&ensp;<code>Iterable[int]=[]</code></dt>
<dd>The program literals forming the rule body.</dd>
<dt><strong><code>choice</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Whether to add a disjunctive or choice rule.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>Integrity constraints and normal rules can be added by using an empty or
singleton head list, respectively.</p></section>
</dd>
<dt id="clingo.Backend.add_weight_rule"><code class="name flex">
<span>def <span class="ident">add_weight_rule</span></span><span>(self, head:<code>Iterable</code>[<code>int</code>], lower:<code>int</code>, body:<code>Iterable</code>[<code>Tuple</code>[<code>int</code>,<code>int</code>]], choice:<code>bool</code>=<code>False</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a disjuntive or choice rule with one weight constraint with a lower bound
in the body to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>The program atoms forming the rule head.</dd>
<dt><strong><code>lower</code></strong> :&ensp;<code>int</code></dt>
<dd>The lower bound.</dd>
<dt><strong><code>body</code></strong> :&ensp;<code>Iterable[Tuple[int,int]]</code></dt>
<dd>The pairs of program literals and weights forming the elements of the
weight constraint.</dd>
<dt><strong><code>choice</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Whether to add a disjunctive or choice rule.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.Configuration"><code class="flex name class">
<span>class <span class="ident">Configuration</span><span>
</code></dt>
<dd>
<section class="desc"><p>Allows for changing the configuration of the underlying solver.</p>
<p>Options are organized hierarchically. To change and inspect an option use:</p>
<pre><code class="hljs python">config.group.subgroup.option = "value"
value = config.group.subgroup.option
</code></pre>
<p>There are also arrays of option groups that can be accessed using integer
indices:</p>
<pre><code class="hljs python">config.group.subgroup[0].option = "value1"
config.group.subgroup[1].option = "value2"
</code></pre>
<p>To list the subgroups of an option group, use the <code><a title="clingo.Configuration.keys" href="#clingo.Configuration.keys">Configuration.keys</a></code> member.
Array option groups, like solver, have a non-negative length and can be
iterated. Furthermore, there are meta options having key <code>configuration</code>.
Assigning a meta option sets a number of related options.
To get further
information about an option or option group <code>&lt;opt&gt;</code>, call <code>description(&lt;opt&gt;)</code>.</p>
<h2 id="notes">Notes</h2>
<p>When integers are assigned to options, they are automatically converted to
strings. The value of an option is always a string.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows how to modify the configuration to enumerate all
models:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; prg = clingo.Control()
&gt;&gt;&gt; prg.configuration.solve.description("models")
'Compute at most %A models (0 for all)\n'
&gt;&gt;&gt; prg.configuration.solve.models = 0
&gt;&gt;&gt; prg.add("base", [], "{a;b}.")
&gt;&gt;&gt; prg.ground([("base", [])])
&gt;&gt;&gt; prg.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer:
Answer: a
Answer: b
Answer: a b
SAT
</code></pre></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.Configuration.keys"><code class="name">var <span class="ident">keys</span><span> : <code>Optional</code>[<code>List</code>[<code>str</code>]]</span></code></dt>
<dd>
<section class="desc"><p>The list of names of sub-option groups or options.</p>
<p>The list is <code>None</code> if the current object is not an option group.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.Configuration.description"><code class="name flex">
<span>def <span class="ident">description</span></span><span>(self, name:<code>str</code>) -> <code>str</code></span>
</code></dt>
<dd>
<section class="desc"><p>Get a description for a option or option group.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.Control"><code class="flex name class">
<span>class <span class="ident">Control</span></span><span>(arguments:<code>Iterable</code>[<code>str</code>]=[], logger:<code>Callable</code>[[<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code>,<code>str</code>],<code>None</code>]=<code>None</code>, message_limit:<code>int</code>=20)</span>
</code></dt>
<dd>
<section class="desc"><p>Control object for the grounding/solving process.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arguments</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>Arguments to the grounder and solver.</dd>
<dt><strong><code>logger</code></strong> :&ensp;<code>Callable[[<a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a>,str],None]=None</code></dt>
<dd>Function to intercept messages normally printed to standard error.</dd>
<dt><strong><code>message_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of messages passed to the logger.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Note that only gringo options (without <code>--text</code>) and clasp's search options are
supported. Furthermore, a <code><a title="clingo.Control" href="#clingo.Control">Control</a></code> object is blocked while a search call is
active; you must not call any member function during search.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.Control.configuration"><code class="name">var <span class="ident">configuration</span><span> : <code><a title="clingo.Configuration" href="#clingo.Configuration">Configuration</a></code></span></code></dt>
<dd>
<section class="desc"><p><code><a title="clingo.Configuration" href="#clingo.Configuration">Configuration</a></code> object to change the configuration.</p></section>
</dd>
<dt id="clingo.Control.enable_cleanup"><code class="name">var <span class="ident">enable_cleanup</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>Whether to enable automatic calls to <code><a title="clingo.Control.cleanup" href="#clingo.Control.cleanup">Control.cleanup()</a></code>.</p></section>
</dd>
<dt id="clingo.Control.enable_enumeration_assumption"><code class="name">var <span class="ident">enable_enumeration_assumption</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>Whether do discard or keep learnt information from enumeration modes.</p>
<p>If the enumeration assumption is enabled, then all information learnt from
clasp's various enumeration modes is removed after a solve call. This includes
enumeration of cautious or brave consequences, enumeration of answer sets with
or without projection, or finding optimal models; as well as clauses added with
<code><a title="clingo.SolveControl.add_clause" href="#clingo.SolveControl.add_clause">SolveControl.add_clause()</a></code>.</p>
<h2 id="notes">Notes</h2>
<p>Initially the enumeration assumption is enabled.</p>
<p>In general, the enumeration assumption should be enabled whenever there are
multiple calls to solve. Otherwise, the behavior of the solver will be
unpredictable because there are no guarantees which information exactly is
kept. There might be small speed benefits when disabling the enumeration
assumption for single shot solving.</p></section>
</dd>
<dt id="clingo.Control.is_conflicting"><code class="name">var <span class="ident">is_conflicting</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>Whether the internal program representation is conflicting.</p>
<p>If this (read-only) property is true, solve calls return immediately with an
unsatisfiable solve result.</p>
<h2 id="notes">Notes</h2>
<p>Conflicts first have to be detected, e.g., initial unit propagation results in
an empty clause, or later if an empty clause is resolved during solving. Hence,
the property might be false even if the problem is unsatisfiable.</p></section>
</dd>
<dt id="clingo.Control.statistics"><code class="name">var <span class="ident">statistics</span><span> : <code>dict</code></span></code></dt>
<dd>
<section class="desc"><p>A <code>dict</code> containing solve statistics of the last solve call.</p>
<h2 id="notes">Notes</h2>
<p>The statistics correspond to the <code>--stats</code> output of clingo. The detail of the
statistics depends on what level is requested on the command line. Furthermore,
there are some functions like <code><a title="clingo.Control.release_external" href="#clingo.Control.release_external">Control.release_external()</a></code> that start a new
solving step resetting the current step statistics. It is best to access the
statistics right after solving.</p>
<p>This property is only available in clingo.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows how to dump the solving statistics in json format:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import json
&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; ctl.add("base", [], "{a}.")
&gt;&gt;&gt; ctl.ground([("base", [])])
&gt;&gt;&gt; ctl.solve()
SAT
&gt;&gt;&gt; print(json.dumps(ctl.statistics['solving'], sort_keys=True, indent=4,
... separators=(',', ': ')))
{
    "solvers": {
        "choices": 1.0,
        "conflicts": 0.0,
        "conflicts_analyzed": 0.0,
        "restarts": 0.0,
        "restarts_last": 0.0
    }
}
</code></pre></section>
</dd>
<dt id="clingo.Control.symbolic_atoms"><code class="name">var <span class="ident">symbolic_atoms</span><span> : <code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code></span></code></dt>
<dd>
<section class="desc"><p><code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code> object to inspect the symbolic atoms.</p></section>
</dd>
<dt id="clingo.Control.theory_atoms"><code class="name">var <span class="ident">theory_atoms</span><span> : <code><a title="clingo.TheoryAtomIter" href="#clingo.TheoryAtomIter">TheoryAtomIter</a></code></span></code></dt>
<dd>
<section class="desc"><p>A <code><a title="clingo.TheoryAtomIter" href="#clingo.TheoryAtomIter">TheoryAtomIter</a></code> object, which can be used to iterate over the theory atoms.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.Control.add"><code class="name flex">
<span>def <span class="ident">add</span></span><span>(self, name:<code>str</code>, parameters:<code>Iterable</code>[<code>str</code>], program:<code>str</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Extend the logic program with the given non-ground logic program in string form.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of program block to add.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>Iterable[str]</code></dt>
<dd>The parameters of the program block to add.</dd>
<dt><strong><code>program</code></strong> :&ensp;<code>str</code></dt>
<dd>The non-ground program in string form.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.ground" href="#clingo.Control.ground">Control.ground()</a></code></p></section>
</dd>
<dt id="clingo.Control.assign_external"><code class="name flex">
<span>def <span class="ident">assign_external</span></span><span>(self, external:<code>Union</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>,<code>int</code>], truth:<code>Optional</code>[<code>bool</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Assign a truth value to an external atom.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>external</code></strong> :&ensp;<code>Union[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>,int]</code></dt>
<dd>A symbol or program literal representing the external atom.</dd>
<dt><strong><code>truth</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>A Boolean fixes the external to the respective truth value; and None leaves
its truth value open.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.release_external" href="#clingo.Control.release_external">Control.release_external()</a></code>, <code><a title="clingo.SolveControl.symbolic_atoms" href="#clingo.SolveControl.symbolic_atoms">SolveControl.symbolic_atoms</a></code>, <code><a title="clingo.SymbolicAtom.is_external" href="#clingo.SymbolicAtom.is_external">SymbolicAtom.is_external</a></code></p>
<h2 id="notes">Notes</h2>
<p>The truth value of an external atom can be changed before each solve call. An
atom is treated as external if it has been declared using an <code>#external</code>
directive, and has not been released by calling release_external() or defined
in a logic program with some rule. If the given atom is not external, then the
function has no effect.</p>
<p>For convenience, the truth assigned to atoms over negative program literals is
inverted.</p></section>
</dd>
<dt id="clingo.Control.backend"><code class="name flex">
<span>def <span class="ident">backend</span></span><span>(self) -> <code><a title="clingo.Backend" href="#clingo.Backend">Backend</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>Returns a <code><a title="clingo.Backend" href="#clingo.Backend">Backend</a></code> object providing a low level interface to extend a logic
program.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.Backend" href="#clingo.Backend">Backend</a></code></dt>
</dl></section>
</dd>
<dt id="clingo.Control.builder"><code class="name flex">
<span>def <span class="ident">builder</span></span><span>(self) -> <code><a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>Return a builder to construct a non-ground logic programs.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a></code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a></code></p></section>
</dd>
<dt id="clingo.Control.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span><span>(self) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Cleanup the domain used for grounding by incorporating information from the
solver.</p>
<p>This function cleans up the domain used for grounding.
This is done by first
simplifying the current program representation (falsifying released external
atoms).
Afterwards, the top-level implications are used to either remove atoms
from the domain or mark them as facts.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.enable_cleanup" href="#clingo.Control.enable_cleanup">Control.enable_cleanup</a></code></p>
<h2 id="notes">Notes</h2>
<p>Any atoms falsified are completely removed from the logic program. Hence, a
definition for such an atom in a successive step introduces a fresh atom.</p>
<p>With the current implementation, the function only has an effect if called
after solving and before any function is called that starts a new step.</p>
<p>Typically, it is not necessary to call this function manually because automatic
cleanups are enabled by default.</p></section>
</dd>
<dt id="clingo.Control.get_const"><code class="name flex">
<span>def <span class="ident">get_const</span></span><span>(self, name:<code>str</code>) -> <code>Optional</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]</span>
</code></dt>
<dd>
<section class="desc"><p>Return the symbol for a constant definition of form: <code>#const name = symbol.</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the constant to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>]</code></dt>
<dd>The function returns <code>None</code> if no matching constant definition exists.</dd>
</dl></section>
</dd>
<dt id="clingo.Control.ground"><code class="name flex">
<span>def <span class="ident">ground</span></span><span>(self, parts:<code>Iterable</code>[<code>Tuple</code>[<code>str</code>,<code>Iterable</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]]], context:<code>Any</code>=<code>None</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Ground the given list of program parts specified by tuples of names and arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parts</code></strong> :&ensp;<code>Iterable[Tuple[str,Iterable[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>]]]</code></dt>
<dd>List of tuples of program names and program arguments to ground.</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>Any=None</code></dt>
<dd>A context object whose methods are called during grounding using the
<code>@</code>-syntax (if omitted methods, from the main module are used).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Note that parts of a logic program without an explicit <code>#program</code> specification
are by default put into a program called <code>base</code> without arguments.</p>
<h2 id="examples">Examples</h2>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; ctl.add("p", ["t"], "q(t).")
&gt;&gt;&gt; parts = []
&gt;&gt;&gt; parts.append(("p", [1]))
&gt;&gt;&gt; parts.append(("p", [2]))
&gt;&gt;&gt; ctl.ground(parts)
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: q(1) q(2)
SAT
</code></pre></section>
</dd>
<dt id="clingo.Control.interrupt"><code class="name flex">
<span>def <span class="ident">interrupt</span></span><span>(self) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Interrupt the active solve call.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>This function is thread-safe and can be called from a signal handler. If no
search is active, the subsequent call to <code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code> is interrupted. The
result of the <code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code> method can be used to query if the search was
interrupted.</p></section>
</dd>
<dt id="clingo.Control.load"><code class="name flex">
<span>def <span class="ident">load</span></span><span>(self, path:<code>str</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Extend the logic program with a (non-ground) logic program in a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to load.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Control.register_observer"><code class="name flex">
<span>def <span class="ident">register_observer</span></span><span>(self, observer:<code><a title="clingo.Observer" href="#clingo.Observer">Observer</a></code>, replace:<code>bool</code>=<code>False</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Registers the given observer to inspect the produced grounding.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>observer</code></strong> :&ensp;<code><a title="clingo.Observer" href="#clingo.Observer">Observer</a></code></dt>
<dd>The observer to register. See below for a description of the requirede
interface.</dd>
<dt><strong><code>replace</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>If set to true, the output is just passed to the observer and nolonger to
the underlying solver (or any previously registered observers).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>Not all functions the <code><a title="clingo.Observer" href="#clingo.Observer">Observer</a></code> interface have to be implemented and can be
omitted if not needed.</p></section>
</dd>
<dt id="clingo.Control.register_propagator"><code class="name flex">
<span>def <span class="ident">register_propagator</span></span><span>(self, propagator:<code><a title="clingo.Propagator" href="#clingo.Propagator">Propagator</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Registers the given propagator with all solvers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>propagator</code></strong> :&ensp;<code><a title="clingo.Propagator" href="#clingo.Propagator">Propagator</a></code></dt>
<dd>The propagator to register.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>Each symbolic or theory atom is uniquely associated with a positive program
atom in form of a positive integer. Program literals additionally have a sign
to represent default negation. Furthermore, there are non-zero integer solver
literals. There is a surjective mapping from program atoms to solver literals.</p>
<p>All methods called during propagation use solver literals whereas
<code><a title="clingo.SymbolicAtom.literal" href="#clingo.SymbolicAtom.literal">SymbolicAtom.literal</a></code> and <code><a title="clingo.TheoryAtom.literal" href="#clingo.TheoryAtom.literal">TheoryAtom.literal</a></code> return program literals. The
function <code><a title="clingo.PropagateInit.solver_literal" href="#clingo.PropagateInit.solver_literal">PropagateInit.solver_literal()</a></code> can be used to map program literals or
condition ids to solver literals.</p>
<p>Not all functions of the <code><a title="clingo.Propagator" href="#clingo.Propagator">Propagator</a></code> interface have to be implemented and can
be omitted if not needed.</p></section>
</dd>
<dt id="clingo.Control.release_external"><code class="name flex">
<span>def <span class="ident">release_external</span></span><span>(self, symbol:<code>Union</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>,<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Release an external atom represented by the given symbol or program literal.</p>
<p>This function causes the corresponding atom to become permanently false if
there is no definition for the atom in the program. Otherwise, the function has
no effect.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>Union[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>,int]</code></dt>
<dd>The symbolic atom or program atom to release.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>If the program literal is negative, the corresponding atom is released.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows the effect of assigning and releasing and external
atom.</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; ctl.add("base", [], "a. #external b.")
&gt;&gt;&gt; ctl.ground([("base", [])])
&gt;&gt;&gt; ctl.assign_external(clingo.Function("b"), True)
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: b a
SAT
&gt;&gt;&gt; ctl.release_external(clingo.Function("b"))
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: a
SAT
</code></pre></section>
</dd>
<dt id="clingo.Control.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span><span>(self, assumptions:<code>Iterable</code>[<code>Union</code>[<code>Tuple</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>,<code>bool</code>],<code>int</code>]]=[], on_model:<code>Callable</code>[[<code><a title="clingo.Model" href="#clingo.Model">Model</a></code>],<code>Optional</code>[<code>bool</code>]]=<code>None</code>, on_statistics:<code>Callable</code>[[<code><a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a></code>,<code><a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a></code>],<code>None</code>]=<code>None</code>, on_finish:<code>Callable</code>[[<code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code>],<code>None</code>]=<code>None</code>, on_core:<code>Callable</code>[[<code>Sequence</code>[<code>int</code>]],<code>None</code>]=<code>None</code>, yield_:<code>bool</code>=<code>False</code>, async_:<code>bool</code>=<code>False</code>) -> <code>Union</code>[<code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code>,<code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code>]</span>
</code></dt>
<dd>
<section class="desc"><p>Starts a search.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assumptions</code></strong> :&ensp;<code>Iterable[Union[Tuple[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>,bool],int]]=[]</code></dt>
<dd>List of (atom, boolean) tuples or program literals that serve
as assumptions for the solve call, e.g., solving under
assumptions <code>[(Function("a"), True)]</code> only admits answer sets
that contain atom <code>a</code>.</dd>
<dt><strong><code>on_model</code></strong> :&ensp;<code>Callable[[<a title="clingo.Model" href="#clingo.Model">Model</a>],Optional[bool]]=None</code></dt>
<dd>Optional callback for intercepting models.
A <code><a title="clingo.Model" href="#clingo.Model">Model</a></code> object is passed to the callback.
The search can be interruped from the model callback by
returning False.</dd>
<dt><strong><code>on_statistics</code></strong> :&ensp;<code>Callable[[<a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a>,<a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a>],None]=None</code></dt>
<dd>Optional callback to update statistics.
The step and accumulated statistics are passed as arguments.</dd>
<dt><strong><code>on_finish</code></strong> :&ensp;<code>Callable[[<a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a>],None]=None</code></dt>
<dd>Optional callback called once search has finished.
A <code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code> also indicating whether the solve call has been intrrupted
is passed to the callback.</dd>
<dt><strong><code>on_core</code></strong> :&ensp;<code>Callable[[Sequence[int]],None]=None</code></dt>
<dd>Optional callback called with the assumptions that made a problem
unsatisfiable.</dd>
<dt><strong><code>yield_</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>The resulting <code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code> is iterable yielding <code><a title="clingo.Model" href="#clingo.Model">Model</a></code> objects.</dd>
<dt><strong><code>async_</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>The solve call and the method <code><a title="clingo.SolveHandle.resume" href="#clingo.SolveHandle.resume">SolveHandle.resume()</a></code> of the returned handle
are non-blocking.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a>,<a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a>]</code></dt>
<dd>The return value depends on the parameters. If either <code>yield_</code> or <code>async_</code>
is true, then a handle is returned. Otherwise, a <code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code> is returned.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If neither <code>yield_</code> nor <code>async_</code> is set, the function returns a SolveResult right
away.</p>
<p>Note that in gringo or in clingo with lparse or text output enabled this
function just grounds and returns a SolveResult where <code><a title="clingo.SolveResult.unknown" href="#clingo.SolveResult.unknown">SolveResult.unknown</a></code>
is true.</p>
<p>If this function is used in embedded Python code, you might want to start
clingo using the <code>--outf=3</code> option to disable all output from clingo.</p>
<p>Note that asynchronous solving is only available in clingo with thread support
enabled. Furthermore, the on_model and on_finish callbacks are called from
another thread. To ensure that the methods can be called, make sure to not use
any functions that block Python's GIL indefinitely.</p>
<p>This function as well as blocking functions on the <code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code> release the GIL
but are not thread-safe.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows how to intercept models with a callback:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control("0")
&gt;&gt;&gt; ctl.add("p", [], "1 { a; b } 1.")
&gt;&gt;&gt; ctl.ground([("p", [])])
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: a
Answer: b
SAT
</code></pre>
<p>The following example shows how to yield models:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control("0")
&gt;&gt;&gt; ctl.add("p", [], "1 { a; b } 1.")
&gt;&gt;&gt; ctl.ground([("p", [])])
&gt;&gt;&gt; with ctl.solve(yield_=True) as handle:
...     for m in handle: print("Answer: {}".format(m))
...     handle.get()
...
Answer: a
Answer: b
SAT
</code></pre>
<p>The following example shows how to solve asynchronously:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control("0")
&gt;&gt;&gt; ctl.add("p", [], "1 { a; b } 1.")
&gt;&gt;&gt; ctl.ground([("p", [])])
&gt;&gt;&gt; with ctl.solve(on_model=lambda m: print("Answer: {}".format(m)), async_=True) as handle:
...     while not handle.wait(0): pass
...     handle.get()
...
Answer: a
Answer: b
SAT
</code></pre></section>
</dd>
</dl>
</dd>
<dt id="clingo.Flag"><code class="flex name class">
<span>class <span class="ident">Flag</span></span><span>(value:<code>bool</code>=<code>False</code>)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper object to parse command-line flags.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>The initial value of the flag.</dd>
</dl></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.Flag.value"><code class="name">var <span class="ident">value</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>The value of the flag.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.HeuristicType"><code class="flex name class">
<span>class <span class="ident">HeuristicType</span><span>
</code></dt>
<dd>
<section class="desc"><p>Enumeration of the different heuristic types.</p>
<p><code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code> objects have a readable string representation, implement
Python's rich comparison operators, and can be used as dictionary keys.</p>
<p>Furthermore, they cannot be constructed from Python. Instead the following
preconstructed class attributes
are available:</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Level</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>Heuristic modification to set the level of an atom.</dd>
<dt><strong><code>Sign</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>Heuristic modification to set the sign of an atom.</dd>
<dt><strong><code>Factor</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>Heuristic modification to set the decaying factor of an atom.</dd>
<dt><strong><code>Init</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>Heuristic modification to set the inital score of an atom.</dd>
<dt><strong><code>True_</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>Heuristic modification to make an atom true.</dd>
<dt><strong><code>False_</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>Heuristic modification to make an atom false.</dd>
</dl></section>
<h3>Class variables</h3>
<dl>
<dt id="clingo.HeuristicType.Factor"><code class="name">var <span class="ident">Factor</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.HeuristicType.False_"><code class="name">var <span class="ident">False_</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.HeuristicType.Init"><code class="name">var <span class="ident">Init</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.HeuristicType.Level"><code class="name">var <span class="ident">Level</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.HeuristicType.Sign"><code class="name">var <span class="ident">Sign</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.HeuristicType.True_"><code class="name">var <span class="ident">True_</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="clingo.MessageCode"><code class="flex name class">
<span>class <span class="ident">MessageCode</span><span>
</code></dt>
<dd>
<section class="desc"><p>Enumeration of the different types of messages.</p>
<p><code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code> objects have a readable string representation, implement Python's
rich comparison operators, and can be used as dictionary keys.</p>
<p>Furthermore, they cannot be constructed from Python. Instead the following
preconstructed class attributes are available:</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>OperationUndefined</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>Inform about an undefined arithmetic operation or unsupported weight of an
aggregate.</dd>
<dt><strong><code>RuntimeError</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>To report multiple errors; a corresponding runtime error is raised later.</dd>
<dt><strong><code>AtomUndefined</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>Informs about an undefined atom in program.</dd>
<dt><strong><code>FileIncluded</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>Indicates that the same file was included multiple times.</dd>
<dt><strong><code>VariableUnbounded</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>Informs about a CSP variable with an unbounded domain.</dd>
<dt><strong><code>GlobalVariable</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>Informs about a global variable in a tuple of an aggregate element.</dd>
<dt><strong><code>Other</code></strong> :&ensp;<code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></dt>
<dd>Reports other kinds of messages.</dd>
</dl></section>
<h3>Class variables</h3>
<dl>
<dt id="clingo.MessageCode.AtomUndefined"><code class="name">var <span class="ident">AtomUndefined</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.MessageCode.FileIncluded"><code class="name">var <span class="ident">FileIncluded</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.MessageCode.GlobalVariable"><code class="name">var <span class="ident">GlobalVariable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.MessageCode.OperationUndefined"><code class="name">var <span class="ident">OperationUndefined</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.MessageCode.Other"><code class="name">var <span class="ident">Other</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.MessageCode.RuntimeError"><code class="name">var <span class="ident">RuntimeError</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.MessageCode.VariableUnbounded"><code class="name">var <span class="ident">VariableUnbounded</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="clingo.Model"><code class="flex name class">
<span>class <span class="ident">Model</span><span>
</code></dt>
<dd>
<section class="desc"><p>Provides access to a model during a solve call and provides a <code>SolveContext</code>
object to provided limited support to influence the running search.</p>
<h2 id="notes">Notes</h2>
<p>The string representation of a model object is similar to the output of models
by clingo using the default output.</p>
<p><code><a title="clingo.Model" href="#clingo.Model">Model</a></code> objects cannot be constructed from Python. Instead they are obained
during solving (see <code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code>). Furthermore, the lifetime of a model
object is limited to the scope of the callback it was passed to or until the
search for the next model is started. They must not be stored for later use.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows how to store atoms in a model for usage after
solving:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; ctl.add("base", [], "{a;b}.")
&gt;&gt;&gt; ctl.ground([("base", [])])
&gt;&gt;&gt; ctl.configuration.solve.models="0"
&gt;&gt;&gt; models = []
&gt;&gt;&gt; with ctl.solve(yield_=True) as handle:
...     for model in handle:
...         models.append(model.symbols(atoms=True))
...
&gt;&gt;&gt; sorted(models)
[[], [a], [a, b], [b]]
</code></pre></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.Model.context"><code class="name">var <span class="ident">context</span><span> : <code><a title="clingo.SolveControl" href="#clingo.SolveControl">SolveControl</a></code></span></code></dt>
<dd>
<section class="desc"><p>Object that allows for controlling the running search.</p></section>
</dd>
<dt id="clingo.Model.cost"><code class="name">var <span class="ident">cost</span><span> : <code>List</code>[<code>int</code>]</span></code></dt>
<dd>
<section class="desc"><p>Return the list of integer cost values of the model.</p>
<p>The return values correspond to clasp's cost output.</p></section>
</dd>
<dt id="clingo.Model.number"><code class="name">var <span class="ident">number</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The running number of the model.</p></section>
</dd>
<dt id="clingo.Model.optimality_proven"><code class="name">var <span class="ident">optimality_proven</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>Whether the optimality of the model has been proven.</p></section>
</dd>
<dt id="clingo.Model.thread_id"><code class="name">var <span class="ident">thread_id</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The id of the thread which found the model.</p></section>
</dd>
<dt id="clingo.Model.type"><code class="name">var <span class="ident">type</span><span> : <code><a title="clingo.ModelType" href="#clingo.ModelType">ModelType</a></code></span></code></dt>
<dd>
<section class="desc"><p>The type of the model.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.Model.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span><span>(self, atom:<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Efficiently check if an atom is contained in the model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
<dd>The atom to lookup.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the given atom is contained in the model.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The atom must be represented using a function symbol.</p></section>
</dd>
<dt id="clingo.Model.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span><span>(self, symbols:<code>Iterable</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Extend a model with the given symbols.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>symbols</code></strong> :&ensp;<code>Iterable[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>]</code></dt>
<dd>The symbols to add to the model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>This only has an effect if there is an underlying clingo application, which
will print the added symbols.</p></section>
</dd>
<dt id="clingo.Model.is_true"><code class="name flex">
<span>def <span class="ident">is_true</span></span><span>(self, literal:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Check if the given program literal is true.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The given program literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the given program literal is true.</dd>
</dl></section>
</dd>
<dt id="clingo.Model.symbols"><code class="name flex">
<span>def <span class="ident">symbols</span></span><span>(self, atoms:<code>bool</code>=<code>False</code>, terms:<code>bool</code>=<code>False</code>, shown:<code>bool</code>=<code>False</code>, csp:<code>bool</code>=<code>False</code>, theory:<code>bool</code>=<code>False</code>, complement:<code>bool</code>=<code>False</code>) -> <code>List</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]</span>
</code></dt>
<dd>
<section class="desc"><p>Return the list of atoms, terms, or CSP assignments in the model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atoms</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Select all atoms in the model (independent of <code>#show</code> statements).</dd>
<dt><strong><code>terms</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Select all terms displayed with <code>#show</code> statements in the model.</dd>
<dt><strong><code>shown</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Select all atoms and terms as outputted by clingo.</dd>
<dt><strong><code>csp</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Select all csp assignments (independent of <code>#show</code> statements).</dd>
<dt><strong><code>theory</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Select atoms added with <code><a title="clingo.Model.extend" href="#clingo.Model.extend">Model.extend()</a></code>.</dd>
<dt><strong><code>complement</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>Return the complement of the answer set w.r.t. to the atoms known to the
grounder. (Does not affect csp assignments.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>]</code></dt>
<dd>The selected symbols.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Atoms are represented using functions (<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code> objects), and CSP assignments
are represented using functions with name <code>"$"</code> where the first argument is the
name of the CSP variable and the second its value.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.ModelType"><code class="flex name class">
<span>class <span class="ident">ModelType</span><span>
</code></dt>
<dd>
<section class="desc"><p>Enumeration of the different types of models.</p>
<p><code><a title="clingo.ModelType" href="#clingo.ModelType">ModelType</a></code> objects have a readable string representation, implement Python's
rich comparison operators, and can be used as dictionary keys.</p>
<p>Furthermore, they cannot be constructed from Python. Instead the following
preconstructed class attributes are available:</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>StableModel</code></strong> :&ensp;<code><a title="clingo.ModelType" href="#clingo.ModelType">ModelType</a></code></dt>
<dd>The model captures a stable model.</dd>
<dt><strong><code>BraveConsequences</code></strong> :&ensp;<code><a title="clingo.ModelType" href="#clingo.ModelType">ModelType</a></code></dt>
<dd>The model stores the set of brave consequences.</dd>
<dt><strong><code>CautiousConsequences</code></strong> :&ensp;<code><a title="clingo.ModelType" href="#clingo.ModelType">ModelType</a></code></dt>
<dd>The model stores the set of cautious consequences.</dd>
</dl></section>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ModelType.BraveConsequences"><code class="name">var <span class="ident">BraveConsequences</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.ModelType.CautiousConsequences"><code class="name">var <span class="ident">CautiousConsequences</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.ModelType.StableModel"><code class="name">var <span class="ident">StableModel</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="clingo.Observer"><code class="flex name class">
<span>class <span class="ident">Observer</span><span>
</code></dt>
<dd>
<section class="desc"><p>Interface that has to be implemented to inspect rules produced during
grounding.</p></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.Observer.acyc_edge"><code class="name flex">
<span>def <span class="ident">acyc_edge</span></span><span>(self, node_u:<code>int</code>, node_v:<code>int</code>, condition:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe edge directives passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_u</code></strong> :&ensp;<code>int</code></dt>
<dd>The start vertex of the edge (in form of an integer).</dd>
<dt><strong><code>node_v</code></strong> :&ensp;<code>int</code></dt>
<dd>Тhe end vertex of the edge (in form of an integer).</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The list of program literals forming th condition under which to
add the edge.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.assume"><code class="name flex">
<span>def <span class="ident">assume</span></span><span>(self, literals:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe assumption directives passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literals</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The program literals to assume (positive literals are true and
negative literals false for the next solve call).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.begin_step"><code class="name flex">
<span>def <span class="ident">begin_step</span></span><span>(self) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Marks the beginning of a block of directives passed to the solver.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.end_step"><code class="name flex">
<span>def <span class="ident">end_step</span></span><span>(self) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Marks the end of a block of directives passed to the solver.</p>
<p>This function is called right before solving starts.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.external"><code class="name flex">
<span>def <span class="ident">external</span></span><span>(self, atom:<code>int</code>, value:<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe external statements passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>int</code></dt>
<dd>The external atom in form of a program literal.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code></dt>
<dd>The truth value of the external statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.heuristic"><code class="name flex">
<span>def <span class="ident">heuristic</span></span><span>(self, atom:<code>int</code>, type:<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code>, bias:<code>int</code>, priority:<code>int</code>, condition:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe heuristic directives passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>int</code></dt>
<dd>The program atom heuristically modified.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></dt>
<dd>The type of the modification.</dd>
<dt><strong><code>bias</code></strong> :&ensp;<code>int</code></dt>
<dd>A signed integer.</dd>
<dt><strong><code>priority</code></strong> :&ensp;<code>int</code></dt>
<dd>An unsigned integer.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>List of program literals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.init_program"><code class="name flex">
<span>def <span class="ident">init_program</span></span><span>(self, incremental:<code>bool</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Called once in the beginning.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>incremental</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the program is incremental. If the incremental flag is
true, there can be multiple calls to <code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.minimize"><code class="name flex">
<span>def <span class="ident">minimize</span></span><span>(self, priority:<code>int</code>, literals:<code>Sequence</code>[<code>Tuple</code>[<code>int</code>,<code>int</code>]]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe minimize directives (or weak constraints) passed to the
solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>priority</code></strong> :&ensp;<code>int</code></dt>
<dd>The priority of the directive.</dd>
<dt><strong><code>literals</code></strong> :&ensp;<code>Sequence[Tuple[int,int]]</code></dt>
<dd>List of weighted literals whose sum to minimize (pairs of literal
and weight).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.output_atom"><code class="name flex">
<span>def <span class="ident">output_atom</span></span><span>(self, symbol:<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>, atom:<code>int</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe shown atoms passed to the solver.
Facts do not have an
associated program atom. The value of the atom is set to zero.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code>Symbolic</code></dt>
<dd>The symbolic representation of the atom.</dd>
<dt><strong><code>atom</code></strong> :&ensp;<code>int</code></dt>
<dd>The associated program atom (0 for facts).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.output_csp"><code class="name flex">
<span>def <span class="ident">output_csp</span></span><span>(self, symbol:<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>, value:<code>int</code>, condition:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe shown csp variables passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
<dd>The symbolic representation of the variable.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>The integer value of the variable.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>List of program literals forming the condition when to show the
variable with its value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.output_term"><code class="name flex">
<span>def <span class="ident">output_term</span></span><span>(self, symbol:<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>, condition:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe shown terms passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>symbol</code></strong> :&ensp;<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></dt>
<dd>The symbolic representation of the term.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>List of program literals forming the condition when to show the
term.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.project"><code class="name flex">
<span>def <span class="ident">project</span></span><span>(self, atoms:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe projection directives passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atoms</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The program atoms to project on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.rule"><code class="name flex">
<span>def <span class="ident">rule</span></span><span>(self, choice:<code>bool</code>, head:<code>Sequence</code>[<code>int</code>], body:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe rules passed to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>choice</code></strong> :&ensp;<code>bool</code></dt>
<dd>Determines if the head is a choice or a disjunction.</dd>
<dt><strong><code>head</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>List of program atoms forming the rule head.</dd>
<dt><strong><code>body</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>List of program literals forming the rule body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.theory_atom"><code class="name flex">
<span>def <span class="ident">theory_atom</span></span><span>(self, atom_id_or_zero:<code>int</code>, term_id:<code>int</code>, elements:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe theory atoms without guard.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom_id_or_zero</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the atom or zero for directives.</dd>
<dt><strong><code>term_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The term associated with the atom.</dd>
<dt><strong><code>elements</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The elements of the atom in form of a list of element ids.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.theory_atom_with_guard"><code class="name flex">
<span>def <span class="ident">theory_atom_with_guard</span></span><span>(self, atom_id_or_zero:<code>int</code>, term_id:<code>int</code>, elements:<code>Sequence</code>[<code>int</code>], operator_id:<code>int</code>, right_hand_side_id:<code>int</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe theory atoms with guard.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom_id_or_zero</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the atom or zero for directives.</dd>
<dt><strong><code>term_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The term associated with the atom.</dd>
<dt><strong><code>elements</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The elements of the atom in form of a list of element ids.</dd>
<dt><strong><code>operator_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the operator (a string term).</dd>
<dt><strong><code>right_hand_side_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the term on the right hand side of the atom.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.theory_element"><code class="name flex">
<span>def <span class="ident">theory_element</span></span><span>(self, element_id:<code>int</code>, terms:<code>Sequence</code>[<code>int</code>], condition:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe theory elements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>element_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the element.</dd>
<dt><strong><code>terms</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The term tuple of the element in form of a list of term ids.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The list of program literals forming the condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.theory_term_compound"><code class="name flex">
<span>def <span class="ident">theory_term_compound</span></span><span>(self, term_id:<code>int</code>, name_id_or_type:<code>int</code>, arguments:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe compound theory terms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>term_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the term.</dd>
<dt><strong><code>name_id_or_type</code></strong> :&ensp;<code>int</code></dt>
<dd>The name or type of the term where
- if it is -1, then it is a tuple
- if it is -2, then it is a set
- if it is -3, then it is a list
- otherwise, it is a function and name_id_or_type refers to the id
of the name (in form of a string term)</dd>
<dt><strong><code>arguments</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The arguments of the term in form of a list of term ids.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.theory_term_number"><code class="name flex">
<span>def <span class="ident">theory_term_number</span></span><span>(self, term_id:<code>int</code>, number:<code>int</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe numeric theory terms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>term_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the term.</dd>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code></dt>
<dd>The value of the term.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.theory_term_string"><code class="name flex">
<span>def <span class="ident">theory_term_string</span></span><span>(self, term_id:<code>int</code>, name:<code>str</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe string theory terms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>term_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the term.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The string value of the term.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.Observer.weight_rule"><code class="name flex">
<span>def <span class="ident">weight_rule</span></span><span>(self, choice:<code>bool</code>, head:<code>Sequence</code>[<code>int</code>], lower_bound:<code>int</code>, body:<code>Sequence</code>[<code>Tuple</code>[<code>int</code>,<code>int</code>]]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Observe rules with one weight constraint in the body passed to the
solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>choice</code></strong> :&ensp;<code>bool</code></dt>
<dd>Determines if the head is a choice or a disjunction.</dd>
<dt><strong><code>head</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>List of program atoms forming the head of the rule.</dd>
<dt>lower_bound:</dt>
<dt>The lower bound of the weight constraint in the rule body.</dt>
<dt><strong><code>body</code></strong> :&ensp;<code>Sequence[Tuple[int,int]]</code></dt>
<dd>List of weighted literals (pairs of literal and weight) forming the
elements of the weight constraint.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.ProgramBuilder"><code class="flex name class">
<span>class <span class="ident">ProgramBuilder</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object to build non-ground programs.</p>
<p>Implements: <code>ContextManager[<a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a>]</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.builder" href="#clingo.Control.builder">Control.builder()</a></code>, <code><a title="clingo.parse_program" href="#clingo.parse_program">parse_program()</a></code></p>
<h2 id="notes">Notes</h2>
<p>A <code><a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a></code> is a context manager and must be used with Python's <code>with</code>
statement.</p>
<h2 id="examples">Examples</h2>
<p>The following example parses a program from a string and passes the resulting
<code>AST</code> to the builder:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; prg = "a."
&gt;&gt;&gt; with ctl.builder() as bld:
...    clingo.parse_program(prg, lambda stm: bld.add(stm))
...
&gt;&gt;&gt; ctl.ground([("base", [])])
&gt;&gt;&gt; ctl.solve(on_model=lambda m: print("Answer: {}".format(m)))
Answer: a
SAT
</code></pre></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.ProgramBuilder.add"><code class="name flex">
<span>def <span class="ident">add</span></span><span>(self, statement:<code><a title="clingo.ast.AST" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}#clingo.ast.AST">AST</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Adds a statement in form of an <code><a title="clingo.ast.AST" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}#clingo.ast.AST">AST</a></code> node to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>statement</code></strong> :&ensp;<code><a title="clingo.ast.AST" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}#clingo.ast.AST">AST</a></code></dt>
<dd>The statement to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.PropagateControl"><code class="flex name class">
<span>class <span class="ident">PropagateControl</span><span>
</code></dt>
<dd>
<section class="desc"><p>This object can be used to add clauses and to propagate them.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.register_propagator" href="#clingo.Control.register_propagator">Control.register_propagator()</a></code></p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.PropagateControl.assignment"><code class="name">var <span class="ident">assignment</span><span> : <code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code></span></code></dt>
<dd>
<section class="desc"><p><code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code> object capturing the partial assignment of the current solver thread.</p></section>
</dd>
<dt id="clingo.PropagateControl.thread_id"><code class="name">var <span class="ident">thread_id</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The numeric id of the current solver thread.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.PropagateControl.add_clause"><code class="name flex">
<span>def <span class="ident">add_clause</span></span><span>(self, clause:<code>Iterable</code>[<code>int</code>], tag:<code>bool</code>=<code>False</code>, lock:<code>bool</code>=<code>False</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add the given clause to the solver.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clause</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>List of solver literals forming the clause.</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>If true, the clause applies only in the current solving step.</dd>
<dt><strong><code>lock</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>If true, exclude clause from the solver's regular clause deletion policy.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>This method returns false if the current propagation must be stopped.</dd>
</dl></section>
</dd>
<dt id="clingo.PropagateControl.add_literal"><code class="name flex">
<span>def <span class="ident">add_literal</span></span><span>(self) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Adds a new positive volatile literal to the underlying solver thread.</p>
<p>The literal is only valid within the current solving step and solver thread.
All volatile literals and clauses involving a volatile literal are deleted
after the current search.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The added solver literal.</dd>
</dl></section>
</dd>
<dt id="clingo.PropagateControl.add_nogood"><code class="name flex">
<span>def <span class="ident">add_nogood</span></span><span>(self, clause:<code>Iterable</code>[<code>int</code>], tag:<code>bool</code>=<code>False</code>, lock:<code>bool</code>=<code>False</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Equivalent to <code>self.add_clause([-lit for lit in clause], tag, lock)</code>.</p></section>
</dd>
<dt id="clingo.PropagateControl.add_watch"><code class="name flex">
<span>def <span class="ident">add_watch</span></span><span>(self, literal:<code>int</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a watch for the solver literal in the given phase.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The target solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>Unlike <code><a title="clingo.PropagateInit.add_watch" href="#clingo.PropagateInit.add_watch">PropagateInit.add_watch()</a></code> this does not add a watch to all solver
threads but just the current one.</p></section>
</dd>
<dt id="clingo.PropagateControl.has_watch"><code class="name flex">
<span>def <span class="ident">has_watch</span></span><span>(self, literal:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Check whether a literal is watched in the current solver thread.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The target solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the literal is watched.</dd>
</dl></section>
</dd>
<dt id="clingo.PropagateControl.propagate"><code class="name flex">
<span>def <span class="ident">propagate</span></span><span>(self) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Propagate literals implied by added clauses.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>This method returns false if the current propagation must be stopped.</dd>
</dl></section>
</dd>
<dt id="clingo.PropagateControl.remove_watch"><code class="name flex">
<span>def <span class="ident">remove_watch</span></span><span>(self, literal:<code>int</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Removes the watch (if any) for the given solver literal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The target solver literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.PropagateInit"><code class="flex name class">
<span>class <span class="ident">PropagateInit</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object that is used to initialize a propagator before each solving step.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.register_propagator" href="#clingo.Control.register_propagator">Control.register_propagator()</a></code></p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.PropagateInit.assignment"><code class="name">var <span class="ident">assignment</span><span> : <code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code></span></code></dt>
<dd>
<section class="desc"><p><code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code> object capturing the top level assignment.</p></section>
</dd>
<dt id="clingo.PropagateInit.check_mode"><code class="name">var <span class="ident">check_mode</span><span> : <code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code></span></code></dt>
<dd>
<section class="desc"><p><code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code> controlling when to call <code>Propagator.check</code>.</p></section>
</dd>
<dt id="clingo.PropagateInit.number_of_threads"><code class="name">var <span class="ident">number_of_threads</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The number of solver threads used in the corresponding solve call.</p></section>
</dd>
<dt id="clingo.PropagateInit.symbolic_atoms"><code class="name">var <span class="ident">symbolic_atoms</span><span> : <code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code></span></code></dt>
<dd>
<section class="desc"><p>The symbolic atoms captured by a <code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code> object.</p></section>
</dd>
<dt id="clingo.PropagateInit.theory_atoms"><code class="name">var <span class="ident">theory_atoms</span><span> : <code><a title="clingo.TheoryAtomIter" href="#clingo.TheoryAtomIter">TheoryAtomIter</a></code></span></code></dt>
<dd>
<section class="desc"><p>A <code><a title="clingo.TheoryAtomIter" href="#clingo.TheoryAtomIter">TheoryAtomIter</a></code> object to iterate over all theory atoms.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.PropagateInit.add_clause"><code class="name flex">
<span>def <span class="ident">add_clause</span></span><span>(self, clause:<code>Iterable</code>[<code>int</code>]) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Statically adds the given clause to the problem.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clause</code></strong> :&ensp;<code>Iterable[int]</code></dt>
<dd>The clause over solver literals to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns false if the program becomes unsatisfiable.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If this function returns false, initialization should be stopped and no further
functions of the <code><a title="clingo.PropagateInit" href="#clingo.PropagateInit">PropagateInit</a></code> and related objects should be called.</p></section>
</dd>
<dt id="clingo.PropagateInit.add_literal"><code class="name flex">
<span>def <span class="ident">add_literal</span></span><span>(self, freeze:<code>bool</code>=<code>True</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Statically adds a literal to the solver.</p>
<p>To be able to use the variable in clauses during propagation or add watches to
it, it has to be frozen. Otherwise, it might be removed during preprocessing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>freeze</code></strong> :&ensp;<code>bool=True</code></dt>
<dd>Whether to freeze the variable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Returns the added literal.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If literals are added to the solver, subsequent calls to <code>add_clause</code> and
<code>propagate</code> are expensive. It is best to add literals in batches.</p></section>
</dd>
<dt id="clingo.PropagateInit.add_minimize"><code class="name flex">
<span>def <span class="ident">add_minimize</span></span><span>(self, literal:<code>int</code>, weight:<code>int</code>, priority:<code>int</code>=0) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Extends the solver's minimize constraint with the given weighted literal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The literal to add.</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>int</code></dt>
<dd>The weight of the literal.</dd>
<dt><strong><code>priority</code></strong> :&ensp;<code>int=0</code></dt>
<dd>The priority of the literal.</dd>
</dl></section>
</dd>
<dt id="clingo.PropagateInit.add_watch"><code class="name flex">
<span>def <span class="ident">add_watch</span></span><span>(self, literal:<code>int</code>, thread_id:<code>Optional</code>[<code>int</code>]=<code>None</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a watch for the solver literal in the given phase.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver literal to watch.</dd>
<dt><strong><code>thread_id</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>The id of the thread to watch the literal. If the is <code>None</code> then all active
threads will watch the literal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.PropagateInit.add_weight_constraint"><code class="name flex">
<span>def <span class="ident">add_weight_constraint</span></span><span>(self, literal:<code>int</code>, literals:<code>Iterable</code>[<code>Tuple</code>[<code>int</code>,<code>int</code>]], bound:<code>int</code>, type:<code>int</code>=0, compare_equal:<code>bool</code>=<code>False</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Statically adds a constraint of form</p>
<pre><code class="hljs python">literal &lt;=&gt; { l=w | (l, w) in literals } &gt;= bound
</code></pre>
<p>to the solver.</p>
<ul>
<li>If <code>type &lt; 0</code>, then <code>&lt;=&gt;</code> is a left implication.</li>
<li>If <code>type &gt; 0</code>, then <code>&lt;=&gt;</code> is a right implication.</li>
<li>Otherwise, <code>&lt;=&gt;</code> is an equivalence.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>The literal associated with the constraint.</dd>
<dt><strong><code>literals</code></strong> :&ensp;<code>Iterable[Tuple[int,int]]</code></dt>
<dd>The weighted literals of the constrain.</dd>
<dt><strong><code>bound</code></strong> :&ensp;<code>int</code></dt>
<dd>The bound of the constraint.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>int</code></dt>
<dd>Add a weight constraint of the given type.</dd>
<dt><strong><code>compare_equal</code></strong> :&ensp;<code>bool=False</code></dt>
<dd>A Boolean indicating whether to compare equal or less than equal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns false if the program becomes unsatisfiable.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If this function returns false, initialization should be stopped and no further
functions of the <code><a title="clingo.PropagateInit" href="#clingo.PropagateInit">PropagateInit</a></code> and related objects should be called.</p></section>
</dd>
<dt id="clingo.PropagateInit.propagate"><code class="name flex">
<span>def <span class="ident">propagate</span></span><span>(self) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Propagates consequences of the underlying problem excluding registered propagators.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns false if the program becomes unsatisfiable.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function has no effect if SAT-preprocessing is enabled.</p>
<p>If this function returns false, initialization should be stopped and no further
functions of the <code><a title="clingo.PropagateInit" href="#clingo.PropagateInit">PropagateInit</a></code> and related objects should be called.</p></section>
</dd>
<dt id="clingo.PropagateInit.solver_literal"><code class="name flex">
<span>def <span class="ident">solver_literal</span></span><span>(self, literal:<code>int</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Maps the given program literal or condition id to its solver literal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literal</code></strong> :&ensp;<code>int</code></dt>
<dd>A program literal or condition id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>A solver literal.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.Propagator"><code class="flex name class">
<span>class <span class="ident">Propagator</span><span>
</code></dt>
<dd>
<section class="desc"></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.Propagator.check"><code class="name flex">
<span>def <span class="ident">check</span></span><span>(self, control:<code><a title="clingo.PropagateControl" href="#clingo.PropagateControl">PropagateControl</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>This function is similar to propagate but is called without a change
set on propagation fixpoints.</p>
<p>When exactly this function is called, can be configured using the @ref
PropagateInit.check_mode property.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>control</code></strong> :&ensp;<code><a title="clingo.PropagateControl" href="#clingo.PropagateControl">PropagateControl</a></code></dt>
<dd>Object to control propagation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>This function is called even if no watches have been added.</p></section>
</dd>
<dt id="clingo.Propagator.decide"><code class="name flex">
<span>def <span class="ident">decide</span></span><span>(self, thread_id:<code>int</code>, assignment:<code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code>, fallback:<code>int</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>This function allows a propagator to implement domain-specific
heuristics.</p>
<p>It is called whenever propagation reaches a fixed point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thread_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver thread id.</dd>
<dt><strong><code>assignment</code></strong> :&ensp;<code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code></dt>
<dd>Object for inspecting the partial assignment of the solver.</dd>
<dt><strong><code>fallback</code></strong> :&ensp;<code>int</code></dt>
<dd>The literal choosen by the solver's heuristic.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Тhe next solver literal to make true.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function should return a free solver literal that is to be
assigned true. In case multiple propagators are registered, this
function can return 0 to let a propagator registered later make a
decision. If all propagators return 0, then the fallback literal is
used.</p></section>
</dd>
<dt id="clingo.Propagator.init"><code class="name flex">
<span>def <span class="ident">init</span></span><span>(self, init:<code><a title="clingo.PropagateInit" href="#clingo.PropagateInit">PropagateInit</a></code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>This function is called once before each solving step.</p>
<p>It is used to map relevant program literals to solver literals, add
watches for solver literals, and initialize the data structures used
during propagation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>init</code></strong> :&ensp;<code><a title="clingo.PropagateInit" href="#clingo.PropagateInit">PropagateInit</a></code></dt>
<dd>Object to initialize the propagator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>This is the last point to access theory atoms.
Once the search has
started, they are no longer accessible.</p></section>
</dd>
<dt id="clingo.Propagator.propagate"><code class="name flex">
<span>def <span class="ident">propagate</span></span><span>(self, control:<code><a title="clingo.PropagateControl" href="#clingo.PropagateControl">PropagateControl</a></code>, changes:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Can be used to propagate solver literals given a partial assignment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>control</code></strong> :&ensp;<code><a title="clingo.PropagateControl" href="#clingo.PropagateControl">PropagateControl</a></code></dt>
<dd>Object to control propagation.</dd>
<dt><strong><code>changes</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>List of watched solver literals assigned to true.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>Called during propagation with a non-empty list of watched solver
literals that have been assigned to true since the last call to either
propagate, undo, (or the start of the search) - the change set. Only
watched solver literals are contained in the change set. Each literal
in the change set is true w.r.t. the current Assignment.
<code><a title="clingo.PropagateControl.add_clause" href="#clingo.PropagateControl.add_clause">PropagateControl.add_clause()</a></code> can be used to add clauses. If a clause
is unit resulting, it can be propagated using
<code><a title="clingo.PropagateControl.propagate" href="#clingo.PropagateControl.propagate">PropagateControl.propagate()</a></code>. If either of the two methods returns
False, the propagate function must return immediately.</p>
<pre><code class="hljs python">c = ...
if not control.add_clause(c) or not control.propagate(c):
    return
</code></pre>
<p>Note that this function can be called from different solving threads.
Each thread has its own assignment and id, which can be obtained using
<code><a title="clingo.PropagateControl.thread_id" href="#clingo.PropagateControl.thread_id">PropagateControl.thread_id</a></code>.</p></section>
</dd>
<dt id="clingo.Propagator.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span><span>(self, thread_id:<code>int</code>, assignment:<code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code>, changes:<code>Sequence</code>[<code>int</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Called whenever a solver with the given id undos assignments to watched
solver literals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thread_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The solver thread id.</dd>
<dt><strong><code>assignment</code></strong> :&ensp;<code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code></dt>
<dd>Object for inspecting the partial assignment of the solver.</dd>
<dt><strong><code>changes</code></strong> :&ensp;<code>Sequence[int]</code></dt>
<dd>The list of watched solver literals whose assignment is undone.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="notes">Notes</h2>
<p>This function is meant to update assignment dependent state in a
propagator but not to modify the current state of the solver.
Furthermore, errors raised in the function lead to program termination.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.PropagatorCheckMode"><code class="flex name class">
<span>class <span class="ident">PropagatorCheckMode</span><span>
</code></dt>
<dd>
<section class="desc"><p>Enumeration of supported check modes for propagators.</p>
<p>Note that total checks are subject to the lock when a model is found. This
means that information from previously found models can be used to discard
assignments in check calls.</p>
<p><code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code> objects have a readable string representation, implement
Python's rich comparison operators, and can be used as dictionary keys.</p>
<p>Furthermore, they cannot be constructed from Python. Instead the following
preconstructed class attributes are available:</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Off</code></strong> :&ensp;<code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code></dt>
<dd>Do not call <code>Propagator.check</code> at all.</dd>
<dt><strong><code>Total</code></strong> :&ensp;<code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code></dt>
<dd>Call <code>Propagator.check</code> on total assignments.</dd>
<dt><strong><code>Fixpoint</code></strong> :&ensp;<code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code></dt>
<dd>Call <code>Propagator.check</code> on propagation fixpoints.</dd>
<dt><strong><code>Both</code></strong> :&ensp;<code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code></dt>
<dd>Call <code>Propagator.check</code> on propagation fixpoints and total assignments.</dd>
</dl></section>
<h3>Class variables</h3>
<dl>
<dt id="clingo.PropagatorCheckMode.Both"><code class="name">var <span class="ident">Both</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.PropagatorCheckMode.Fixpoint"><code class="name">var <span class="ident">Fixpoint</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.PropagatorCheckMode.Off"><code class="name">var <span class="ident">Off</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.PropagatorCheckMode.Total"><code class="name">var <span class="ident">Total</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="clingo.SolveControl"><code class="flex name class">
<span>class <span class="ident">SolveControl</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object that allows for controlling a running search.</p>
<p><code><a title="clingo.SolveControl" href="#clingo.SolveControl">SolveControl</a></code> objects cannot be constructed from Python. Instead they are
available via <code><a title="clingo.Model.context" href="#clingo.Model.context">Model.context</a></code>.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.SolveControl.symbolic_atoms"><code class="name">var <span class="ident">symbolic_atoms</span><span> : <code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code></span></code></dt>
<dd>
<section class="desc"><p><code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code> object to inspect the symbolic atoms.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.SolveControl.add_clause"><code class="name flex">
<span>def <span class="ident">add_clause</span></span><span>(self, literals:<code>Iterable</code>[<code>Union</code>[<code>Tuple</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>,<code>bool</code>],<code>int</code>]]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Add a clause that applies to the current solving step during the search.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literals</code></strong> :&ensp;<code>Iterable[Union[Tuple[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>,bool],int]]</code></dt>
<dd>List of literals either represented as pairs of symbolic atoms and Booleans
or as program literals.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function can only be called in a model callback or while iterating when
using a <code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code>.</p></section>
</dd>
<dt id="clingo.SolveControl.add_nogood"><code class="name flex">
<span>def <span class="ident">add_nogood</span></span><span>(self, literals:<code>Iterable</code>[<code>Union</code>[<code>Tuple</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>,<code>bool</code>],<code>int</code>]]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Equivalent to <code><a title="clingo.SolveControl.add_clause" href="#clingo.SolveControl.add_clause">SolveControl.add_clause()</a></code> with the literals inverted.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.SolveHandle"><code class="flex name class">
<span>class <span class="ident">SolveHandle</span><span>
</code></dt>
<dd>
<section class="desc"><p>Handle for solve calls.</p>
<p><code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code> objects cannot be created from Python. Instead they are returned
by <code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code>. They can be used to control solving, like, retrieving
models or cancelling a search.</p>
<p>Implements: <code>ContextManager[<a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a>]</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code></p>
<h2 id="notes">Notes</h2>
<p>A <code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code> is a context manager and must be used with Python's <code>with</code>
statement.</p>
<p>Blocking functions in this object release the GIL. They are not thread-safe
though.</p></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.SolveHandle.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span><span>(self) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Cancel the running search.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.interrupt" href="#clingo.Control.interrupt">Control.interrupt()</a></code></p></section>
</dd>
<dt id="clingo.SolveHandle.core"><code class="name flex">
<span>def <span class="ident">core</span></span><span>(self) -> <code>List</code>[<code>int</code>]</span>
</code></dt>
<dd>
<section class="desc"><p>The subset of assumptions that made the problem unsatisfiable.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[int]</code></dt>
</dl></section>
</dd>
<dt id="clingo.SolveHandle.get"><code class="name flex">
<span>def <span class="ident">get</span></span><span>(self) -> <code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code></span>
</code></dt>
<dd>
<section class="desc"><p>Get the result of a solve call.</p>
<p>If the search is not completed yet, the function blocks until the result is
ready.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code></dt>
</dl></section>
</dd>
<dt id="clingo.SolveHandle.model"><code class="name flex">
<span>def <span class="ident">model</span></span><span>(self) -> <code>Optional</code>[<code><a title="clingo.Model" href="#clingo.Model">Model</a></code>]</span>
</code></dt>
<dd>
<section class="desc"><p>Get the current model if there is any.</p>
<h2 id="examples">Examples</h2>
<p>The following example shows how to implement a custom solve loop. While more
cumbersome than using a for loop, this kind of loop allows for fine grained
timeout handling between models:</p>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; ctl = clingo.Control()
&gt;&gt;&gt; ctl.configuration.solve.models = 0
&gt;&gt;&gt; ctl.add("base", [], "1 {a;b}.")
&gt;&gt;&gt; ctl.ground([("base", [])])
&gt;&gt;&gt; with prg.solve(yield_=True, async_=True) as hnd:
...     while True:
...         hnd.resume()
...         _ = hnd.wait()
...         m = hnd.model()
...         print(m)
...         if m is None:
...             break
b
a
a b
None
</code></pre></section>
</dd>
<dt id="clingo.SolveHandle.resume"><code class="name flex">
<span>def <span class="ident">resume</span></span><span>(self) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Discards the last model and starts searching for the next one.</p>
<h2 id="notes">Notes</h2>
<p>If the search has been started asynchronously, this function starts the search
in the background.</p></section>
</dd>
<dt id="clingo.SolveHandle.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span><span>(self, timeout:<code>Optional</code>[<code>float</code>]=<code>None</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Wait for solve call to finish or the next result with an optional timeout.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Optional[float]=None</code></dt>
<dd>If a timeout is given, the function blocks for at most timeout seconds.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Returns a Boolean indicating whether the solve call has finished or the
next result is ready.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.SolveResult"><code class="flex name class">
<span>class <span class="ident">SolveResult</span><span>
</code></dt>
<dd>
<section class="desc"><p>Captures the result of a solve call.</p>
<p><code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code> objects cannot be constructed from Python. Instead they are
returned by the solve methods of the Control object.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.SolveResult.exhausted"><code class="name">var <span class="ident">exhausted</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>True if the search space was exhausted.</p></section>
</dd>
<dt id="clingo.SolveResult.interrupted"><code class="name">var <span class="ident">interrupted</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>True if the search was interrupted.</p></section>
</dd>
<dt id="clingo.SolveResult.satisfiable"><code class="name">var <span class="ident">satisfiable</span><span> : <code>Optional</code>[<code>bool</code>]</span></code></dt>
<dd>
<section class="desc"><p>True if the problem is satisfiable, False if the problem is unsatisfiable, or
None if the satisfiablity is not known.</p></section>
</dd>
<dt id="clingo.SolveResult.unknown"><code class="name">var <span class="ident">unknown</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>True if the satisfiablity is not known.</p>
<p>This is equivalent to satisfiable is None.</p></section>
</dd>
<dt id="clingo.SolveResult.unsatisfiable"><code class="name">var <span class="ident">unsatisfiable</span><span> : <code>Optional</code>[<code>bool</code>]</span></code></dt>
<dd>
<section class="desc"><p>True if the problem is unsatisfiable, false if the problem is satisfiable, or
<code>None</code> if the satisfiablity is not known.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.StatisticsArray"><code class="flex name class">
<span>class <span class="ident">StatisticsArray</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object to modify statistics stored in an array.</p>
<p>Note that only inplace concatenation and no deletion is supported.</p>
<p>Implements: <code>MutableSequence[Union[<a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a>,<a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a>,float]]</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code></p>
<h2 id="notes">Notes</h2>
<p>The <code><a title="clingo.StatisticsArray.update" href="#clingo.StatisticsArray.update">StatisticsArray.update()</a></code> function provides convenient means to initialize
and modify a statistics array.</p></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.StatisticsArray.append"><code class="name flex">
<span>def <span class="ident">append</span></span><span>(self, value:<code>Any</code>) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Append a value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>Any</code></dt>
<dd>A nested structure composed of floats, sequences, and mappings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.StatisticsArray.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span><span>(self, values:<code>Iterable</code>[<code>Any</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Extend the statistics array with the given values.</p>
<h2 id="paremeters">Paremeters</h2>
<p>values: Sequence[Any]
A sequence of nested structures composed of floats, sequences, and
mappings.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>append</code></p></section>
</dd>
<dt id="clingo.StatisticsArray.update"><code class="name flex">
<span>def <span class="ident">update</span></span><span>(self, values:<code>Sequence</code>[<code>Any</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Update a statistics array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>Sequence[Any]</code></dt>
<dd>A sequence of nested structures composed of floats, callable, sequences,
and mappings. A callable can be used to update an existing value, it
receives the previous numeric value (or None if absent) as argument and
must return an updated numeric value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.StatisticsMap"><code class="flex name class">
<span>class <span class="ident">StatisticsMap</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object to capture statistics stored in a map.</p>
<p>This class does not support item deletion.</p>
<p>Implements: <code>Mapping[str,Union[<a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a>,<a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a>,float]]</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Control.solve" href="#clingo.Control.solve">Control.solve()</a></code></p>
<h2 id="notes">Notes</h2>
<p>The <code><a title="clingo.StatisticsMap.update" href="#clingo.StatisticsMap.update">StatisticsMap.update()</a></code> function provides convenient means to initialize
and modify a statistics map.</p></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.StatisticsMap.items"><code class="name flex">
<span>def <span class="ident">items</span></span><span>(self) -> <code>AbstractSet</code>[<code>Tuple</code>[<code>str</code>,<code>Union</code>[<code><a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a></code>,<code><a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a></code>,<code>float</code>]]]</span>
</code></dt>
<dd>
<section class="desc"><p>Return the items of the map.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AbstractSet[Tuple[str, Union[<a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a>,<a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a>,float]]]</code></dt>
<dd>The items of the map.</dd>
</dl></section>
</dd>
<dt id="clingo.StatisticsMap.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span><span>(self) -> <code>AbstractSet</code>[<code>str</code>]</span>
</code></dt>
<dd>
<section class="desc"><p>Return the keys of the map.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AbstractSet[str]</code></dt>
<dd>The keys of the map.</dd>
</dl></section>
</dd>
<dt id="clingo.StatisticsMap.update"><code class="name flex">
<span>def <span class="ident">update</span></span><span>(self, values:<code>Mapping</code>[<code>str</code>,<code>Any</code>]) -> <code>None</code></span>
</code></dt>
<dd>
<section class="desc"><p>Update the map with the given values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>Mapping[Any]</code></dt>
<dd>A mapping of nested structures composed of floats, callable, sequences,
and mappings. A callable can be used to update an existing value, it
receives the previous numeric value (or None if absent) as argument and
must return an updated numeric value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
</dl></section>
</dd>
<dt id="clingo.StatisticsMap.values"><code class="name flex">
<span>def <span class="ident">values</span></span><span>(self) -> <code>ValuesView</code>[<code>Union</code>[<code><a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a></code>,<code><a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a></code>,<code>float</code>]]</span>
</code></dt>
<dd>
<section class="desc"><p>Return the values of the map.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ValuesView[Union[<a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a>,<a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a>,float]]</code></dt>
<dd>The values of the map.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.Symbol"><code class="flex name class">
<span>class <span class="ident">Symbol</span><span>
</code></dt>
<dd>
<section class="desc"><p>Represents a gringo symbol.</p>
<p>This includes numbers, strings, functions (including constants with
<code>len(arguments) == 0</code> and tuples with <code>len(name) == 0</code>), <code>#inf</code> and <code>#sup</code>.</p>
<p>Symbol objects implemente Python's rich comparison operators and are ordered
like in gringo. They can also be used as keys in dictionaries. Their string
representation corresponds to their gringo representation.</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="notes">Notes</h2>
<p>Note that this class does not have a constructor. Instead there are the
functions <code><a title="clingo.Number" href="#clingo.Number">Number()</a></code>, <code><a title="clingo.String" href="#clingo.String">String()</a></code>, and <code><a title="clingo.Function" href="#clingo.Function">Function()</a></code> to construct symbol objects or the
preconstructed symbols <code><a title="clingo.Infimum" href="#clingo.Infimum">Infimum</a></code> and <code><a title="clingo.Supremum" href="#clingo.Supremum">Supremum</a></code>.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.Symbol.arguments"><code class="name">var <span class="ident">arguments</span><span> : <code>List</code>[<code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code>]</span></code></dt>
<dd>
<section class="desc"><p>The arguments of a function.</p></section>
</dd>
<dt id="clingo.Symbol.name"><code class="name">var <span class="ident">name</span><span> : <code>str</code></span></code></dt>
<dd>
<section class="desc"><p>The name of a function.</p></section>
</dd>
<dt id="clingo.Symbol.negative"><code class="name">var <span class="ident">negative</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>The inverted sign of a function.</p></section>
</dd>
<dt id="clingo.Symbol.number"><code class="name">var <span class="ident">number</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The value of a number.</p></section>
</dd>
<dt id="clingo.Symbol.positive"><code class="name">var <span class="ident">positive</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>The sign of a function.</p></section>
</dd>
<dt id="clingo.Symbol.string"><code class="name">var <span class="ident">string</span><span> : <code>str</code></span></code></dt>
<dd>
<section class="desc"><p>The value of a string.</p></section>
</dd>
<dt id="clingo.Symbol.type"><code class="name">var <span class="ident">type</span><span> : <code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></span></code></dt>
<dd>
<section class="desc"><p>The type of the symbol.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.Symbol.match"><code class="name flex">
<span>def <span class="ident">match</span></span><span>(self, name:<code>str</code>, arity:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Check if this is a function symbol with the given signature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the function.</dd>
<dt><strong><code>arity</code></strong> :&ensp;<code>int</code></dt>
<dd>The arity of the function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the function matches.</dd>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.SymbolType"><code class="flex name class">
<span>class <span class="ident">SymbolType</span><span>
</code></dt>
<dd>
<section class="desc"><p>Enumeration of the different types of symbols.</p>
<p><code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code> objects have a readable string representation, implement Python's
rich comparison operators, and can be used as dictionary keys.</p>
<p>Furthermore, they cannot be constructed from Python. Instead the following
preconstructed objects are available:</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Number</code></strong> :&ensp;<code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></dt>
<dd>A numeric symbol, e.g., <code>1</code>.</dd>
<dt><strong><code>String</code></strong> :&ensp;<code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></dt>
<dd>A string symbol, e.g., <code>"a"</code>.</dd>
<dt><strong><code>Function</code></strong> :&ensp;<code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></dt>
<dd>A function symbol, e.g., <code>c</code>, <code>(1, "a")</code>, or <code>f(1,"a")</code>.</dd>
<dt><strong><code>Infimum</code></strong> :&ensp;<code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></dt>
<dd>The <code>#inf</code> symbol.</dd>
<dt><strong><code>Supremum</code></strong> :&ensp;<code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></dt>
<dd>The <code>#sup</code> symbol</dd>
</dl></section>
<h3>Class variables</h3>
<dl>
<dt id="clingo.SymbolType.Function"><code class="name">var <span class="ident">Function</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.SymbolType.Infimum"><code class="name">var <span class="ident">Infimum</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.SymbolType.Number"><code class="name">var <span class="ident">Number</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.SymbolType.String"><code class="name">var <span class="ident">String</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.SymbolType.Supremum"><code class="name">var <span class="ident">Supremum</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="clingo.SymbolicAtom"><code class="flex name class">
<span>class <span class="ident">SymbolicAtom</span><span>
</code></dt>
<dd>
<section class="desc"><p>Captures a symbolic atom and provides properties to inspect its state.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.SymbolicAtom.is_external"><code class="name">var <span class="ident">is_external</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>Whether the atom is an external atom.</p></section>
</dd>
<dt id="clingo.SymbolicAtom.is_fact"><code class="name">var <span class="ident">is_fact</span><span> : <code>bool</code></span></code></dt>
<dd>
<section class="desc"><p>Whether the atom is a fact.</p></section>
</dd>
<dt id="clingo.SymbolicAtom.literal"><code class="name">var <span class="ident">literal</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The program literal associated with the atom.</p></section>
</dd>
<dt id="clingo.SymbolicAtom.symbol"><code class="name">var <span class="ident">symbol</span><span> : <code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></span></code></dt>
<dd>
<section class="desc"><p>The representation of the atom in form of a symbol.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.SymbolicAtom.match"><code class="name flex">
<span>def <span class="ident">match</span></span><span>(self, name:<code>str</code>, arity:<code>int</code>) -> <code>bool</code></span>
</code></dt>
<dd>
<section class="desc"><p>Check if the atom matches the given signature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the function.</dd>
<dt><strong><code>arity</code></strong> :&ensp;<code>int</code></dt>
<dd>The arity of the function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the function matches.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.Symbol.match" href="#clingo.Symbol.match">Symbol.match()</a></code></p></section>
</dd>
</dl>
</dd>
<dt id="clingo.SymbolicAtomIter"><code class="flex name class">
<span>class <span class="ident">SymbolicAtomIter</span><span>
</code></dt>
<dd>
<section class="desc"><p>Implements: <code>Iterator[<a title="clingo.SymbolicAtom" href="#clingo.SymbolicAtom">SymbolicAtom</a>]</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code></p></section>
</dd>
<dt id="clingo.SymbolicAtoms"><code class="flex name class">
<span>class <span class="ident">SymbolicAtoms</span><span>
</code></dt>
<dd>
<section class="desc"><p>This class provides read-only access to the atom base of the grounder.</p>
<p>Implements: <code>Lookup[Union[<a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a>,int],<a title="clingo.SymbolicAtom" href="#clingo.SymbolicAtom">SymbolicAtom</a>]</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="hljs python">&gt;&gt;&gt; import clingo
&gt;&gt;&gt; prg = clingo.Control()
&gt;&gt;&gt; prg.add('base', [], '''\
... p(1).
... { p(3) }.
... #external p(1..3).
...
... q(X) :- p(X).
... ''')
&gt;&gt;&gt; prg.ground([("base", [])])
&gt;&gt;&gt; len(prg.symbolic_atoms)
6
&gt;&gt;&gt; prg.symbolic_atoms[clingo.Function("p", [2])] is not None
True
&gt;&gt;&gt; prg.symbolic_atoms[clingo.Function("p", [4])] is None
True
&gt;&gt;&gt; prg.symbolic_atoms.signatures
[('p', 1L, True), ('q', 1L, True)]
&gt;&gt;&gt; [(x.symbol, x.is_fact, x.is_external)
...  for x in prg.symbolic_atoms.by_signature("p", 1)]
[(p(1), True, False), (p(3), False, False), (p(2), False, True)]
</code></pre></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.SymbolicAtoms.signatures"><code class="name">var <span class="ident">signatures</span><span> : <code>List</code>[<code>Tuple</code>[<code>str</code>,<code>int</code>,<code>bool</code>]]</span></code></dt>
<dd>
<section class="desc"><p>The list of predicate signatures occurring in the program.</p>
<p>The Boolean indicates the sign of the signature.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.SymbolicAtoms.by_signature"><code class="name flex">
<span>def <span class="ident">by_signature</span></span><span>(self, name:<code>str</code>, arity:<code>int</code>, positive:<code>bool</code>=<code>True</code>) -> <code>Iterator</code>[<code><a title="clingo.SymbolicAtom" href="#clingo.SymbolicAtom">SymbolicAtom</a></code>]</span>
</code></dt>
<dd>
<section class="desc"><p>Return an iterator over the symbolic atoms with the given signature.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the signature.</dd>
<dt><strong><code>arity</code></strong> :&ensp;<code>int</code></dt>
<dd>The arity of the signature.</dd>
<dt><strong><code>positive</code></strong> :&ensp;<code>bool=True</code></dt>
<dd>The sign of the signature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterator[<a title="clingo.SymbolicAtom" href="#clingo.SymbolicAtom">SymbolicAtom</a>]</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.TheoryAtom"><code class="flex name class">
<span>class <span class="ident">TheoryAtom</span><span>
</code></dt>
<dd>
<section class="desc"><p>Class to represent theory atoms.</p>
<p>Theory atoms have a readable string representation, implement Python's rich
comparison operators, and can be used as dictionary keys.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.TheoryAtom.elements"><code class="name">var <span class="ident">elements</span><span> : <code>List</code>[<code><a title="clingo.TheoryElement" href="#clingo.TheoryElement">TheoryElement</a></code>]</span></code></dt>
<dd>
<section class="desc"><p>The elements of the atom.</p></section>
</dd>
<dt id="clingo.TheoryAtom.guard"><code class="name">var <span class="ident">guard</span><span> : <code>Tuple</code>[<code>str</code>,<code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code>]</span></code></dt>
<dd>
<section class="desc"><p>The guard of the atom or None if the atom has no guard.</p></section>
</dd>
<dt id="clingo.TheoryAtom.literal"><code class="name">var <span class="ident">literal</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The program literal associated with the atom.</p></section>
</dd>
<dt id="clingo.TheoryAtom.term"><code class="name">var <span class="ident">term</span><span> : <code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code></span></code></dt>
<dd>
<section class="desc"><p>The term of the atom.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.TheoryAtomIter"><code class="flex name class">
<span>class <span class="ident">TheoryAtomIter</span><span>
</code></dt>
<dd>
<section class="desc"><p>Implements: <code>Iterator[<a title="clingo.TheoryAtom" href="#clingo.TheoryAtom">TheoryAtom</a>]</code>.</p></section>
</dd>
<dt id="clingo.TheoryElement"><code class="flex name class">
<span>class <span class="ident">TheoryElement</span><span>
</code></dt>
<dd>
<section class="desc"><p>Class to represent theory elements.</p>
<p>Theory elements have a readable string representation, implement Python's rich
comparison operators, and can be used as dictionary keys.</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.TheoryElement.condition"><code class="name">var <span class="ident">condition</span><span> : <code>List</code>[<code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code>]</span></code></dt>
<dd>
<section class="desc"><p>The condition of the element.</p></section>
</dd>
<dt id="clingo.TheoryElement.condition_id"><code class="name">var <span class="ident">condition_id</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>Each condition has an id. This id can be passed to
<code><a title="clingo.PropagateInit.solver_literal" href="#clingo.PropagateInit.solver_literal">PropagateInit.solver_literal()</a></code> to obtain a solver literal equivalent to the
condition.</p></section>
</dd>
<dt id="clingo.TheoryElement.terms"><code class="name">var <span class="ident">terms</span><span> : <code>List</code>[<code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code>]</span></code></dt>
<dd>
<section class="desc"><p>The tuple of the element.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.TheoryTerm"><code class="flex name class">
<span>class <span class="ident">TheoryTerm</span><span>
</code></dt>
<dd>
<section class="desc"><p><code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code> objects represent theory terms.</p>
<p>Theory terms have a readable string representation, implement Python's rich
comparison operators, and can be used as dictionary keys.</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p></section>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.TheoryTerm.arguments"><code class="name">var <span class="ident">arguments</span><span> : <code>List</code>[<code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code>]</span></code></dt>
<dd>
<section class="desc"><p>The arguments of the term (for functions, tuples, list, and sets).</p></section>
</dd>
<dt id="clingo.TheoryTerm.name"><code class="name">var <span class="ident">name</span><span> : <code>str</code></span></code></dt>
<dd>
<section class="desc"><p>The name of the term (for symbols and functions).</p></section>
</dd>
<dt id="clingo.TheoryTerm.number"><code class="name">var <span class="ident">number</span><span> : <code>int</code></span></code></dt>
<dd>
<section class="desc"><p>The numeric representation of the term (for numbers).</p></section>
</dd>
<dt id="clingo.TheoryTerm.type"><code class="name">var <span class="ident">type</span><span> : <code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></span></code></dt>
<dd>
<section class="desc"><p>The type of the theory term.</p></section>
</dd>
</dl>
</dd>
<dt id="clingo.TheoryTermType"><code class="flex name class">
<span>class <span class="ident">TheoryTermType</span><span>
</code></dt>
<dd>
<section class="desc"><p>Enumeration of the different types of theory terms.</p>
<p><code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code> objects have a readable string representation, implement
Python's rich comparison operators, and can be used as dictionary keys.</p>
<p>Furthermore, they cannot be constructed from Python. Instead the following
preconstructed objects are available:</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Function</code></strong> :&ensp;<code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></dt>
<dd>For a function theory terms.</dd>
<dt><strong><code>Number</code></strong> :&ensp;<code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></dt>
<dd>For numeric theory terms.</dd>
<dt><strong><code>Symbol</code></strong> :&ensp;<code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></dt>
<dd>For symbolic theory terms (symbol here means the term is a string).</dd>
<dt><strong><code>List</code></strong> :&ensp;<code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></dt>
<dd>For list theory terms.</dd>
<dt><strong><code>Tuple</code></strong> :&ensp;<code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></dt>
<dd>For tuple theory terms.</dd>
<dt><strong><code>Set</code></strong> :&ensp;<code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></dt>
<dd>For set theory terms.</dd>
</dl></section>
<h3>Class variables</h3>
<dl>
<dt id="clingo.TheoryTermType.Function"><code class="name">var <span class="ident">Function</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TheoryTermType.List"><code class="name">var <span class="ident">List</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TheoryTermType.Number"><code class="name">var <span class="ident">Number</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TheoryTermType.Set"><code class="name">var <span class="ident">Set</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TheoryTermType.Symbol"><code class="name">var <span class="ident">Symbol</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TheoryTermType.Tuple"><code class="name">var <span class="ident">Tuple</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="clingo.Trail"><code class="flex name class">
<span>class <span class="ident">Trail</span><span>
</code></dt>
<dd>
<section class="desc"><p>Object to access literals assigned by the solver in chronological order.</p>
<p>Literals in the trail are ordered by decision levels, where the first literal
with a larger level than the previous literals is a decision; the following
literals with same level are implied by this decision literal. Each decision
level up to and including the current decision level has a valid offset in the
trail.</p>
<p>Implements: <code>Sequence[int]</code>.</p></section>
<h3>Methods</h3>
<dl>
<dt id="clingo.Trail.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span><span>(self, level:<code>int</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Returns the offset of the decision literal with the given decision level in the
trail.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The decision level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
</dl></section>
</dd>
<dt id="clingo.Trail.end"><code class="name flex">
<span>def <span class="ident">end</span></span><span>(self, level:<code>int</code>) -> <code>int</code></span>
</code></dt>
<dd>
<section class="desc"><p>Returns the offset following the last literal with the given decision literal
in the trail.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>The decision level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
</dl></section>
</dd>
</dl>
</dd>
<dt id="clingo.TruthValue"><code class="flex name class">
<span>class <span class="ident">TruthValue</span><span>
</code></dt>
<dd>
<section class="desc"><p>Enumeration of the different truth values.</p>
<p><code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code> objects have a readable string representation, implement Python's
rich comparison operators, and can be used as dictionary keys.</p>
<p>Furthermore, they cannot be constructed from Python. Instead the following
preconstructed class attributes are available:</p>
<p>Implements: <code>Hashable</code>, <code>Comparable</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>True_</code></strong> :&ensp;<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code></dt>
<dd>Represents truth value true.</dd>
<dt><strong><code>False_</code></strong> :&ensp;<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code></dt>
<dd>Represents truth value true.</dd>
<dt><strong><code>Free</code></strong> :&ensp;<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code></dt>
<dd>Represents absence of a truth value.</dd>
<dt><strong><code>Release</code></strong> :&ensp;<code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code></dt>
<dd>Indicates that an atom is to be released.</dd>
</dl></section>
<h3>Class variables</h3>
<dl>
<dt id="clingo.TruthValue.False_"><code class="name">var <span class="ident">False_</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TruthValue.Free"><code class="name">var <span class="ident">Free</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TruthValue.Release"><code class="name">var <span class="ident">Release</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="clingo.TruthValue.True_"><code class="name">var <span class="ident">True_</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav class="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul class="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul class="">
<li><code><a title="clingo.ast" href="{{site.baseurl}}{% link clingo/python-api/5.5/ast/index.html %}">clingo.ast</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="two-column">
<li><code><a title="clingo.Infimum" href="#clingo.Infimum">Infimum</a></code></li>
<li><code><a title="clingo.Supremum" href="#clingo.Supremum">Supremum</a></code></li>
<li><code><a title="clingo.__version__" href="#clingo.__version__">__version__</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="clingo.Function" href="#clingo.Function">Function</a></code></li>
<li><code><a title="clingo.Number" href="#clingo.Number">Number</a></code></li>
<li><code><a title="clingo.String" href="#clingo.String">String</a></code></li>
<li><code><a title="clingo.Tuple_" href="#clingo.Tuple_">Tuple_</a></code></li>
<li><code><a title="clingo.clingo_main" href="#clingo.clingo_main">clingo_main</a></code></li>
<li><code><a title="clingo.parse_program" href="#clingo.parse_program">parse_program</a></code></li>
<li><code><a title="clingo.parse_term" href="#clingo.parse_term">parse_term</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingo.Application" href="#clingo.Application">Application</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Application.logger" href="#clingo.Application.logger">logger</a></code></li>
<li><code><a title="clingo.Application.main" href="#clingo.Application.main">main</a></code></li>
<li><code><a title="clingo.Application.register_options" href="#clingo.Application.register_options">register_options</a></code></li>
<li><code><a title="clingo.Application.validate_options" href="#clingo.Application.validate_options">validate_options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ApplicationOptions" href="#clingo.ApplicationOptions">ApplicationOptions</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ApplicationOptions.add" href="#clingo.ApplicationOptions.add">add</a></code></li>
<li><code><a title="clingo.ApplicationOptions.add_flag" href="#clingo.ApplicationOptions.add_flag">add_flag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Assignment" href="#clingo.Assignment">Assignment</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Assignment.decision" href="#clingo.Assignment.decision">decision</a></code></li>
<li><code><a title="clingo.Assignment.decision_level" href="#clingo.Assignment.decision_level">decision_level</a></code></li>
<li><code><a title="clingo.Assignment.has_conflict" href="#clingo.Assignment.has_conflict">has_conflict</a></code></li>
<li><code><a title="clingo.Assignment.has_literal" href="#clingo.Assignment.has_literal">has_literal</a></code></li>
<li><code><a title="clingo.Assignment.is_false" href="#clingo.Assignment.is_false">is_false</a></code></li>
<li><code><a title="clingo.Assignment.is_fixed" href="#clingo.Assignment.is_fixed">is_fixed</a></code></li>
<li><code><a title="clingo.Assignment.is_total" href="#clingo.Assignment.is_total">is_total</a></code></li>
<li><code><a title="clingo.Assignment.is_true" href="#clingo.Assignment.is_true">is_true</a></code></li>
<li><code><a title="clingo.Assignment.level" href="#clingo.Assignment.level">level</a></code></li>
<li><code><a title="clingo.Assignment.root_level" href="#clingo.Assignment.root_level">root_level</a></code></li>
<li><code><a title="clingo.Assignment.trail" href="#clingo.Assignment.trail">trail</a></code></li>
<li><code><a title="clingo.Assignment.value" href="#clingo.Assignment.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Backend" href="#clingo.Backend">Backend</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Backend.add_acyc_edge" href="#clingo.Backend.add_acyc_edge">add_acyc_edge</a></code></li>
<li><code><a title="clingo.Backend.add_assume" href="#clingo.Backend.add_assume">add_assume</a></code></li>
<li><code><a title="clingo.Backend.add_atom" href="#clingo.Backend.add_atom">add_atom</a></code></li>
<li><code><a title="clingo.Backend.add_external" href="#clingo.Backend.add_external">add_external</a></code></li>
<li><code><a title="clingo.Backend.add_heuristic" href="#clingo.Backend.add_heuristic">add_heuristic</a></code></li>
<li><code><a title="clingo.Backend.add_minimize" href="#clingo.Backend.add_minimize">add_minimize</a></code></li>
<li><code><a title="clingo.Backend.add_project" href="#clingo.Backend.add_project">add_project</a></code></li>
<li><code><a title="clingo.Backend.add_rule" href="#clingo.Backend.add_rule">add_rule</a></code></li>
<li><code><a title="clingo.Backend.add_weight_rule" href="#clingo.Backend.add_weight_rule">add_weight_rule</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Configuration" href="#clingo.Configuration">Configuration</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Configuration.description" href="#clingo.Configuration.description">description</a></code></li>
<li><code><a title="clingo.Configuration.keys" href="#clingo.Configuration.keys">keys</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Control" href="#clingo.Control">Control</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Control.add" href="#clingo.Control.add">add</a></code></li>
<li><code><a title="clingo.Control.assign_external" href="#clingo.Control.assign_external">assign_external</a></code></li>
<li><code><a title="clingo.Control.backend" href="#clingo.Control.backend">backend</a></code></li>
<li><code><a title="clingo.Control.builder" href="#clingo.Control.builder">builder</a></code></li>
<li><code><a title="clingo.Control.cleanup" href="#clingo.Control.cleanup">cleanup</a></code></li>
<li><code><a title="clingo.Control.configuration" href="#clingo.Control.configuration">configuration</a></code></li>
<li><code><a title="clingo.Control.enable_cleanup" href="#clingo.Control.enable_cleanup">enable_cleanup</a></code></li>
<li><code><a title="clingo.Control.enable_enumeration_assumption" href="#clingo.Control.enable_enumeration_assumption">enable_enumeration_assumption</a></code></li>
<li><code><a title="clingo.Control.get_const" href="#clingo.Control.get_const">get_const</a></code></li>
<li><code><a title="clingo.Control.ground" href="#clingo.Control.ground">ground</a></code></li>
<li><code><a title="clingo.Control.interrupt" href="#clingo.Control.interrupt">interrupt</a></code></li>
<li><code><a title="clingo.Control.is_conflicting" href="#clingo.Control.is_conflicting">is_conflicting</a></code></li>
<li><code><a title="clingo.Control.load" href="#clingo.Control.load">load</a></code></li>
<li><code><a title="clingo.Control.register_observer" href="#clingo.Control.register_observer">register_observer</a></code></li>
<li><code><a title="clingo.Control.register_propagator" href="#clingo.Control.register_propagator">register_propagator</a></code></li>
<li><code><a title="clingo.Control.release_external" href="#clingo.Control.release_external">release_external</a></code></li>
<li><code><a title="clingo.Control.solve" href="#clingo.Control.solve">solve</a></code></li>
<li><code><a title="clingo.Control.statistics" href="#clingo.Control.statistics">statistics</a></code></li>
<li><code><a title="clingo.Control.symbolic_atoms" href="#clingo.Control.symbolic_atoms">symbolic_atoms</a></code></li>
<li><code><a title="clingo.Control.theory_atoms" href="#clingo.Control.theory_atoms">theory_atoms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Flag" href="#clingo.Flag">Flag</a></code></h4>
<ul class="">
<li><code><a title="clingo.Flag.value" href="#clingo.Flag.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.HeuristicType" href="#clingo.HeuristicType">HeuristicType</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.HeuristicType.Factor" href="#clingo.HeuristicType.Factor">Factor</a></code></li>
<li><code><a title="clingo.HeuristicType.False_" href="#clingo.HeuristicType.False_">False_</a></code></li>
<li><code><a title="clingo.HeuristicType.Init" href="#clingo.HeuristicType.Init">Init</a></code></li>
<li><code><a title="clingo.HeuristicType.Level" href="#clingo.HeuristicType.Level">Level</a></code></li>
<li><code><a title="clingo.HeuristicType.Sign" href="#clingo.HeuristicType.Sign">Sign</a></code></li>
<li><code><a title="clingo.HeuristicType.True_" href="#clingo.HeuristicType.True_">True_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.MessageCode" href="#clingo.MessageCode">MessageCode</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.MessageCode.AtomUndefined" href="#clingo.MessageCode.AtomUndefined">AtomUndefined</a></code></li>
<li><code><a title="clingo.MessageCode.FileIncluded" href="#clingo.MessageCode.FileIncluded">FileIncluded</a></code></li>
<li><code><a title="clingo.MessageCode.GlobalVariable" href="#clingo.MessageCode.GlobalVariable">GlobalVariable</a></code></li>
<li><code><a title="clingo.MessageCode.OperationUndefined" href="#clingo.MessageCode.OperationUndefined">OperationUndefined</a></code></li>
<li><code><a title="clingo.MessageCode.Other" href="#clingo.MessageCode.Other">Other</a></code></li>
<li><code><a title="clingo.MessageCode.RuntimeError" href="#clingo.MessageCode.RuntimeError">RuntimeError</a></code></li>
<li><code><a title="clingo.MessageCode.VariableUnbounded" href="#clingo.MessageCode.VariableUnbounded">VariableUnbounded</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Model" href="#clingo.Model">Model</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Model.contains" href="#clingo.Model.contains">contains</a></code></li>
<li><code><a title="clingo.Model.context" href="#clingo.Model.context">context</a></code></li>
<li><code><a title="clingo.Model.cost" href="#clingo.Model.cost">cost</a></code></li>
<li><code><a title="clingo.Model.extend" href="#clingo.Model.extend">extend</a></code></li>
<li><code><a title="clingo.Model.is_true" href="#clingo.Model.is_true">is_true</a></code></li>
<li><code><a title="clingo.Model.number" href="#clingo.Model.number">number</a></code></li>
<li><code><a title="clingo.Model.optimality_proven" href="#clingo.Model.optimality_proven">optimality_proven</a></code></li>
<li><code><a title="clingo.Model.symbols" href="#clingo.Model.symbols">symbols</a></code></li>
<li><code><a title="clingo.Model.thread_id" href="#clingo.Model.thread_id">thread_id</a></code></li>
<li><code><a title="clingo.Model.type" href="#clingo.Model.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ModelType" href="#clingo.ModelType">ModelType</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ModelType.BraveConsequences" href="#clingo.ModelType.BraveConsequences">BraveConsequences</a></code></li>
<li><code><a title="clingo.ModelType.CautiousConsequences" href="#clingo.ModelType.CautiousConsequences">CautiousConsequences</a></code></li>
<li><code><a title="clingo.ModelType.StableModel" href="#clingo.ModelType.StableModel">StableModel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Observer" href="#clingo.Observer">Observer</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Observer.acyc_edge" href="#clingo.Observer.acyc_edge">acyc_edge</a></code></li>
<li><code><a title="clingo.Observer.assume" href="#clingo.Observer.assume">assume</a></code></li>
<li><code><a title="clingo.Observer.begin_step" href="#clingo.Observer.begin_step">begin_step</a></code></li>
<li><code><a title="clingo.Observer.end_step" href="#clingo.Observer.end_step">end_step</a></code></li>
<li><code><a title="clingo.Observer.external" href="#clingo.Observer.external">external</a></code></li>
<li><code><a title="clingo.Observer.heuristic" href="#clingo.Observer.heuristic">heuristic</a></code></li>
<li><code><a title="clingo.Observer.init_program" href="#clingo.Observer.init_program">init_program</a></code></li>
<li><code><a title="clingo.Observer.minimize" href="#clingo.Observer.minimize">minimize</a></code></li>
<li><code><a title="clingo.Observer.output_atom" href="#clingo.Observer.output_atom">output_atom</a></code></li>
<li><code><a title="clingo.Observer.output_csp" href="#clingo.Observer.output_csp">output_csp</a></code></li>
<li><code><a title="clingo.Observer.output_term" href="#clingo.Observer.output_term">output_term</a></code></li>
<li><code><a title="clingo.Observer.project" href="#clingo.Observer.project">project</a></code></li>
<li><code><a title="clingo.Observer.rule" href="#clingo.Observer.rule">rule</a></code></li>
<li><code><a title="clingo.Observer.theory_atom" href="#clingo.Observer.theory_atom">theory_atom</a></code></li>
<li><code><a title="clingo.Observer.theory_atom_with_guard" href="#clingo.Observer.theory_atom_with_guard">theory_atom_with_guard</a></code></li>
<li><code><a title="clingo.Observer.theory_element" href="#clingo.Observer.theory_element">theory_element</a></code></li>
<li><code><a title="clingo.Observer.theory_term_compound" href="#clingo.Observer.theory_term_compound">theory_term_compound</a></code></li>
<li><code><a title="clingo.Observer.theory_term_number" href="#clingo.Observer.theory_term_number">theory_term_number</a></code></li>
<li><code><a title="clingo.Observer.theory_term_string" href="#clingo.Observer.theory_term_string">theory_term_string</a></code></li>
<li><code><a title="clingo.Observer.weight_rule" href="#clingo.Observer.weight_rule">weight_rule</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ProgramBuilder" href="#clingo.ProgramBuilder">ProgramBuilder</a></code></h4>
<ul class="">
<li><code><a title="clingo.ProgramBuilder.add" href="#clingo.ProgramBuilder.add">add</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.PropagateControl" href="#clingo.PropagateControl">PropagateControl</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.PropagateControl.add_clause" href="#clingo.PropagateControl.add_clause">add_clause</a></code></li>
<li><code><a title="clingo.PropagateControl.add_literal" href="#clingo.PropagateControl.add_literal">add_literal</a></code></li>
<li><code><a title="clingo.PropagateControl.add_nogood" href="#clingo.PropagateControl.add_nogood">add_nogood</a></code></li>
<li><code><a title="clingo.PropagateControl.add_watch" href="#clingo.PropagateControl.add_watch">add_watch</a></code></li>
<li><code><a title="clingo.PropagateControl.assignment" href="#clingo.PropagateControl.assignment">assignment</a></code></li>
<li><code><a title="clingo.PropagateControl.has_watch" href="#clingo.PropagateControl.has_watch">has_watch</a></code></li>
<li><code><a title="clingo.PropagateControl.propagate" href="#clingo.PropagateControl.propagate">propagate</a></code></li>
<li><code><a title="clingo.PropagateControl.remove_watch" href="#clingo.PropagateControl.remove_watch">remove_watch</a></code></li>
<li><code><a title="clingo.PropagateControl.thread_id" href="#clingo.PropagateControl.thread_id">thread_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.PropagateInit" href="#clingo.PropagateInit">PropagateInit</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.PropagateInit.add_clause" href="#clingo.PropagateInit.add_clause">add_clause</a></code></li>
<li><code><a title="clingo.PropagateInit.add_literal" href="#clingo.PropagateInit.add_literal">add_literal</a></code></li>
<li><code><a title="clingo.PropagateInit.add_minimize" href="#clingo.PropagateInit.add_minimize">add_minimize</a></code></li>
<li><code><a title="clingo.PropagateInit.add_watch" href="#clingo.PropagateInit.add_watch">add_watch</a></code></li>
<li><code><a title="clingo.PropagateInit.add_weight_constraint" href="#clingo.PropagateInit.add_weight_constraint">add_weight_constraint</a></code></li>
<li><code><a title="clingo.PropagateInit.assignment" href="#clingo.PropagateInit.assignment">assignment</a></code></li>
<li><code><a title="clingo.PropagateInit.check_mode" href="#clingo.PropagateInit.check_mode">check_mode</a></code></li>
<li><code><a title="clingo.PropagateInit.number_of_threads" href="#clingo.PropagateInit.number_of_threads">number_of_threads</a></code></li>
<li><code><a title="clingo.PropagateInit.propagate" href="#clingo.PropagateInit.propagate">propagate</a></code></li>
<li><code><a title="clingo.PropagateInit.solver_literal" href="#clingo.PropagateInit.solver_literal">solver_literal</a></code></li>
<li><code><a title="clingo.PropagateInit.symbolic_atoms" href="#clingo.PropagateInit.symbolic_atoms">symbolic_atoms</a></code></li>
<li><code><a title="clingo.PropagateInit.theory_atoms" href="#clingo.PropagateInit.theory_atoms">theory_atoms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Propagator" href="#clingo.Propagator">Propagator</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Propagator.check" href="#clingo.Propagator.check">check</a></code></li>
<li><code><a title="clingo.Propagator.decide" href="#clingo.Propagator.decide">decide</a></code></li>
<li><code><a title="clingo.Propagator.init" href="#clingo.Propagator.init">init</a></code></li>
<li><code><a title="clingo.Propagator.propagate" href="#clingo.Propagator.propagate">propagate</a></code></li>
<li><code><a title="clingo.Propagator.undo" href="#clingo.Propagator.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.PropagatorCheckMode" href="#clingo.PropagatorCheckMode">PropagatorCheckMode</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.PropagatorCheckMode.Both" href="#clingo.PropagatorCheckMode.Both">Both</a></code></li>
<li><code><a title="clingo.PropagatorCheckMode.Fixpoint" href="#clingo.PropagatorCheckMode.Fixpoint">Fixpoint</a></code></li>
<li><code><a title="clingo.PropagatorCheckMode.Off" href="#clingo.PropagatorCheckMode.Off">Off</a></code></li>
<li><code><a title="clingo.PropagatorCheckMode.Total" href="#clingo.PropagatorCheckMode.Total">Total</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.SolveControl" href="#clingo.SolveControl">SolveControl</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.SolveControl.add_clause" href="#clingo.SolveControl.add_clause">add_clause</a></code></li>
<li><code><a title="clingo.SolveControl.add_nogood" href="#clingo.SolveControl.add_nogood">add_nogood</a></code></li>
<li><code><a title="clingo.SolveControl.symbolic_atoms" href="#clingo.SolveControl.symbolic_atoms">symbolic_atoms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.SolveHandle" href="#clingo.SolveHandle">SolveHandle</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.SolveHandle.cancel" href="#clingo.SolveHandle.cancel">cancel</a></code></li>
<li><code><a title="clingo.SolveHandle.core" href="#clingo.SolveHandle.core">core</a></code></li>
<li><code><a title="clingo.SolveHandle.get" href="#clingo.SolveHandle.get">get</a></code></li>
<li><code><a title="clingo.SolveHandle.model" href="#clingo.SolveHandle.model">model</a></code></li>
<li><code><a title="clingo.SolveHandle.resume" href="#clingo.SolveHandle.resume">resume</a></code></li>
<li><code><a title="clingo.SolveHandle.wait" href="#clingo.SolveHandle.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.SolveResult" href="#clingo.SolveResult">SolveResult</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.SolveResult.exhausted" href="#clingo.SolveResult.exhausted">exhausted</a></code></li>
<li><code><a title="clingo.SolveResult.interrupted" href="#clingo.SolveResult.interrupted">interrupted</a></code></li>
<li><code><a title="clingo.SolveResult.satisfiable" href="#clingo.SolveResult.satisfiable">satisfiable</a></code></li>
<li><code><a title="clingo.SolveResult.unknown" href="#clingo.SolveResult.unknown">unknown</a></code></li>
<li><code><a title="clingo.SolveResult.unsatisfiable" href="#clingo.SolveResult.unsatisfiable">unsatisfiable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.StatisticsArray" href="#clingo.StatisticsArray">StatisticsArray</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.StatisticsArray.append" href="#clingo.StatisticsArray.append">append</a></code></li>
<li><code><a title="clingo.StatisticsArray.extend" href="#clingo.StatisticsArray.extend">extend</a></code></li>
<li><code><a title="clingo.StatisticsArray.update" href="#clingo.StatisticsArray.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.StatisticsMap" href="#clingo.StatisticsMap">StatisticsMap</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.StatisticsMap.items" href="#clingo.StatisticsMap.items">items</a></code></li>
<li><code><a title="clingo.StatisticsMap.keys" href="#clingo.StatisticsMap.keys">keys</a></code></li>
<li><code><a title="clingo.StatisticsMap.update" href="#clingo.StatisticsMap.update">update</a></code></li>
<li><code><a title="clingo.StatisticsMap.values" href="#clingo.StatisticsMap.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Symbol" href="#clingo.Symbol">Symbol</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Symbol.arguments" href="#clingo.Symbol.arguments">arguments</a></code></li>
<li><code><a title="clingo.Symbol.match" href="#clingo.Symbol.match">match</a></code></li>
<li><code><a title="clingo.Symbol.name" href="#clingo.Symbol.name">name</a></code></li>
<li><code><a title="clingo.Symbol.negative" href="#clingo.Symbol.negative">negative</a></code></li>
<li><code><a title="clingo.Symbol.number" href="#clingo.Symbol.number">number</a></code></li>
<li><code><a title="clingo.Symbol.positive" href="#clingo.Symbol.positive">positive</a></code></li>
<li><code><a title="clingo.Symbol.string" href="#clingo.Symbol.string">string</a></code></li>
<li><code><a title="clingo.Symbol.type" href="#clingo.Symbol.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.SymbolType" href="#clingo.SymbolType">SymbolType</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.SymbolType.Function" href="#clingo.SymbolType.Function">Function</a></code></li>
<li><code><a title="clingo.SymbolType.Infimum" href="#clingo.SymbolType.Infimum">Infimum</a></code></li>
<li><code><a title="clingo.SymbolType.Number" href="#clingo.SymbolType.Number">Number</a></code></li>
<li><code><a title="clingo.SymbolType.String" href="#clingo.SymbolType.String">String</a></code></li>
<li><code><a title="clingo.SymbolType.Supremum" href="#clingo.SymbolType.Supremum">Supremum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.SymbolicAtom" href="#clingo.SymbolicAtom">SymbolicAtom</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.SymbolicAtom.is_external" href="#clingo.SymbolicAtom.is_external">is_external</a></code></li>
<li><code><a title="clingo.SymbolicAtom.is_fact" href="#clingo.SymbolicAtom.is_fact">is_fact</a></code></li>
<li><code><a title="clingo.SymbolicAtom.literal" href="#clingo.SymbolicAtom.literal">literal</a></code></li>
<li><code><a title="clingo.SymbolicAtom.match" href="#clingo.SymbolicAtom.match">match</a></code></li>
<li><code><a title="clingo.SymbolicAtom.symbol" href="#clingo.SymbolicAtom.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.SymbolicAtomIter" href="#clingo.SymbolicAtomIter">SymbolicAtomIter</a></code></h4>
</li>
<li>
<h4><code><a title="clingo.SymbolicAtoms" href="#clingo.SymbolicAtoms">SymbolicAtoms</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.SymbolicAtoms.by_signature" href="#clingo.SymbolicAtoms.by_signature">by_signature</a></code></li>
<li><code><a title="clingo.SymbolicAtoms.signatures" href="#clingo.SymbolicAtoms.signatures">signatures</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.TheoryAtom" href="#clingo.TheoryAtom">TheoryAtom</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.TheoryAtom.elements" href="#clingo.TheoryAtom.elements">elements</a></code></li>
<li><code><a title="clingo.TheoryAtom.guard" href="#clingo.TheoryAtom.guard">guard</a></code></li>
<li><code><a title="clingo.TheoryAtom.literal" href="#clingo.TheoryAtom.literal">literal</a></code></li>
<li><code><a title="clingo.TheoryAtom.term" href="#clingo.TheoryAtom.term">term</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.TheoryAtomIter" href="#clingo.TheoryAtomIter">TheoryAtomIter</a></code></h4>
</li>
<li>
<h4><code><a title="clingo.TheoryElement" href="#clingo.TheoryElement">TheoryElement</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.TheoryElement.condition" href="#clingo.TheoryElement.condition">condition</a></code></li>
<li><code><a title="clingo.TheoryElement.condition_id" href="#clingo.TheoryElement.condition_id">condition_id</a></code></li>
<li><code><a title="clingo.TheoryElement.terms" href="#clingo.TheoryElement.terms">terms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.TheoryTerm" href="#clingo.TheoryTerm">TheoryTerm</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.TheoryTerm.arguments" href="#clingo.TheoryTerm.arguments">arguments</a></code></li>
<li><code><a title="clingo.TheoryTerm.name" href="#clingo.TheoryTerm.name">name</a></code></li>
<li><code><a title="clingo.TheoryTerm.number" href="#clingo.TheoryTerm.number">number</a></code></li>
<li><code><a title="clingo.TheoryTerm.type" href="#clingo.TheoryTerm.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.TheoryTermType" href="#clingo.TheoryTermType">TheoryTermType</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.TheoryTermType.Function" href="#clingo.TheoryTermType.Function">Function</a></code></li>
<li><code><a title="clingo.TheoryTermType.List" href="#clingo.TheoryTermType.List">List</a></code></li>
<li><code><a title="clingo.TheoryTermType.Number" href="#clingo.TheoryTermType.Number">Number</a></code></li>
<li><code><a title="clingo.TheoryTermType.Set" href="#clingo.TheoryTermType.Set">Set</a></code></li>
<li><code><a title="clingo.TheoryTermType.Symbol" href="#clingo.TheoryTermType.Symbol">Symbol</a></code></li>
<li><code><a title="clingo.TheoryTermType.Tuple" href="#clingo.TheoryTermType.Tuple">Tuple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.Trail" href="#clingo.Trail">Trail</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.Trail.begin" href="#clingo.Trail.begin">begin</a></code></li>
<li><code><a title="clingo.Trail.end" href="#clingo.Trail.end">end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.TruthValue" href="#clingo.TruthValue">TruthValue</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.TruthValue.False_" href="#clingo.TruthValue.False_">False_</a></code></li>
<li><code><a title="clingo.TruthValue.Free" href="#clingo.TruthValue.Free">Free</a></code></li>
<li><code><a title="clingo.TruthValue.Release" href="#clingo.TruthValue.Release">Release</a></code></li>
<li><code><a title="clingo.TruthValue.True_" href="#clingo.TruthValue.True_">True_</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<script src="{{site.baseurl}}/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>